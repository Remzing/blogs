<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><meta name="keywords" content="Browser javascript"><meta name="description" content="摘要

浏览器的渲染过程
原理以及优化"><meta name="author" content="renyy"><title>重排（回流）与重绘 - Remzing</title><meta description="摘要  浏览器的渲染过程 原理以及优化"><meta property="og:type" content="article"><meta property="og:title" content="重排（回流）与重绘"><meta property="og:url" content="https://remzing.github.io/posts/c382ea1a/"><meta property="og:site_name" content="任勉之的博客"><meta property="og:description" content="摘要  浏览器的渲染过程 原理以及优化"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/remzing/img/images/WechatIMG6.jpeg"><meta property="article:published_time" content="2020-06-18T19:09:22.000Z"><meta property="article:modified_time" content="2020-08-05T17:29:30.588Z"><meta property="article:author" content="renyy"><meta property="article:tag" content="Browser javascript"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/remzing/img/images/WechatIMG6.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://remzing.github.io/posts/c382ea1a/"},"headline":"重排（回流）与重绘","image":[],"datePublished":"2020-06-18T19:09:22.000Z","dateModified":"2020-08-05T17:29:30.588Z","author":{"@type":"Person","name":"renyy"},"description":"摘要  浏览器的渲染过程 原理以及优化"}</script><link rel="alternative" href="/atom.xml" title="Remzing" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/remzing/img/images/WechatIMG10.jpeg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/remzing/img/images/avatar.png" alt="Remzing" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">简介</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Remzing"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-06-18  <span class="level-item"><i class="far fa-clock"> </i>17 分钟  <i class="fas fa-pencil-alt"> </i>2.6 k</span></div></div><h1 class="title is-3 is-size-4-mobile">重排（回流）与重绘</h1><div class="content"><blockquote><p>摘要</p><ul><li>浏览器的渲染过程</li><li>原理以及优化<a id="more"></a></li></ul></blockquote><h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><p><img src="https://cdn.jsdelivr.net/gh/remzing/img/images/bVblB7y" alt=""></p><p>从上面这个图上，我们可以看到，浏览器渲染过程如下</p><ol><li>解析<code>HTML</code>生成<code>DOM</code>树，解析<code>CSS</code>生成<code>CSSOM</code>树</li><li>将<code>DOM</code>树和<code>CSSOM</code>树结合生成渲染树<code>renderTree</code></li><li><code>Layout</code>(回流): 根据生成的渲染树，进行回流(<code>Layout</code>)，得到节点的几何信息（位置，大小）</li><li><code>Painting</code>(重绘): 根据<strong>渲染树</strong>以及<strong>回流</strong>得到的几何信息，得到节点的<strong>绝对像素</strong></li><li><code>Display</code>:将像素发送给<strong>GPU</strong>，展示在页面上。</li></ol><h3 id="生成渲染树-RenderTree"><a href="#生成渲染树-RenderTree" class="headerlink" title="生成渲染树(RenderTree)"></a>生成渲染树(<code>RenderTree</code>)</h3><p><img src="https://cdn.jsdelivr.net/gh/remzing/img/images/bVblCem" alt=""></p><p>为了构建渲染树，浏览器主要完成了以下工作</p><ol><li>从<code>DOM</code>树的根节点开始遍历每个可见节点。</li><li>对于每个可见的节点，找到<code>CSSOM</code>树中对应的规则，并应用它们。</li><li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li></ol><p>第一步中，既然说到了要遍历<strong>可见</strong>的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p><ol><li>一些不会渲染输出的节点，比如<code>script、meta、link</code>等。</li><li>一些通过<code>css</code>进行隐藏的节点。比如<code>display:none</code>。注意，利用<code>visibility</code>和<code>opacity</code>隐藏的节点，还是会显示在渲染树上的。只有<code>display:none</code>的节点才不会显示在渲染树上。</li></ol><h3 id="回流-Layout"><a href="#回流-Layout" class="headerlink" title="回流(Layout)"></a>回流(<code>Layout</code>)</h3><p>前面我们通过构造渲染树，我们将可见<code>DOM</code>节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(<code>viewport</code>)内的确切位置和大小，这个计算的阶段就是回流。<br>为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历,而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值</p><h3 id="重绘-Painting"><a href="#重绘-Painting" class="headerlink" title="重绘(Painting)"></a>重绘(<code>Painting</code>)</h3><p>通过回流(<code>Layout</code>)阶段，我们知道了所有的可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p><h3 id="何时发生回流重绘"><a href="#何时发生回流重绘" class="headerlink" title="何时发生回流重绘"></a>何时发生回流重绘</h3><p>回流阶段是计算节点的几何信息和位置，那么当<strong>页面布局</strong>或者<strong>几何信息</strong>发生改变时，就需要回流。</p><ol><li>添加或者删除可见的<code>DOM</code>元素</li><li>元素的位置、尺寸发生变化</li><li>页面开始渲染的时候(这肯定避免不了)</li><li>浏览器的视口尺寸大小发生改变(因为回流是根据浏览器视口的大小来计算元素的位置和尺寸大小)</li></ol><p><strong>注意：回流一定会触发重绘，而重绘(非几何信息的样式发生改变)不一定会回流, reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流；</strong></p><p>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p><h3 id="基于回流-Layout-、重绘-Painting-的优化方法"><a href="#基于回流-Layout-、重绘-Painting-的优化方法" class="headerlink" title="基于回流(Layout)、重绘(Painting)的优化方法"></a>基于回流(<code>Layout</code>)、重绘(<code>Painting</code>)的优化方法</h3><h4 id="避免扰乱现代浏览器的优化机制"><a href="#避免扰乱现代浏览器的优化机制" class="headerlink" title="避免扰乱现代浏览器的优化机制"></a>避免扰乱现代浏览器的优化机制</h4><p>在现代浏览器的中，由于每次<strong>回流、重绘</strong>的时候，都需要额外的计算消耗，因此会通过<strong>队列化修改</strong>，并批量执行来优化这一过程。浏览器会将修改操作放入队列里面，直到<strong>过了一段时间</strong>或者<strong>达到一个阈值</strong>，才清空队列。</p><p>但是当你获取布局信息时，会强制刷新队列，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">offsetTop、offsetLeft、offsetWidth、offsetHeight</span><br><span class="line"></span><br><span class="line">scrollTop、scrollLeft、scrollWidth、scrollHeight</span><br><span class="line"></span><br><span class="line">clientTop、clientLeft、clientWidth、clientHeight</span><br><span class="line"></span><br><span class="line">getComputedStyle()</span><br><span class="line"></span><br><span class="line">getBoundingClientRect()</span><br></pre></td></tr></table></figure><p>上面这些方法，都需要获取最新的布局信息，所以浏览器会强制刷新队列并执行回流、重绘，来获取最新的信息。<br>因此我们在修改样式的时候，应该尽量避免使用上面的属性、方法，如果非要使用，可以先缓存起来然后一起获取。</p><h4 id="CSS的修改方式"><a href="#CSS的修改方式" class="headerlink" title="CSS的修改方式"></a><code>CSS</code>的修改方式</h4><p>考虑以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const el &#x3D; document.getElementById(&#39;el&#39;)</span><br><span class="line">el.style.padding &#x3D; &#39;xxx&#39;</span><br><span class="line">el.style.margin &#x3D; &#39;xxx&#39;</span><br><span class="line">el.style.border &#x3D; &#39;xxx&#39;</span><br></pre></td></tr></table></figure><p>这里元素的几何信息有三次被修改了，但是现代浏览器会将起缓存起来，但是如果这期间有通过前面列出来的属性、方法访问位置信息的话就会触发三次回流、重绘。所以还是建议通过<code>cssText</code>或者<code>class</code>的方法一次性修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">el.style.cssText +&#x3D; &#39;border-left: 1px; border-right: 2px; padding:</span><br><span class="line">5px;&#39;;</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">el.className +&#x3D; &#39;xxx&#39;;</span><br></pre></td></tr></table></figure><h4 id="批量修改DOM"><a href="#批量修改DOM" class="headerlink" title="批量修改DOM"></a>批量修改<code>DOM</code></h4><p>当我们需要对<code>DOM</code>进行一系列修改的时候，可以通过以下几种方式减少回流重绘次数：</p><ul><li>隐藏元素，应用修改，重新显示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function appendDataToElement (appendToElement, data) &#123; </span><br><span class="line">    let li;</span><br><span class="line">    for ( let i &#x3D; 0; i &lt; data.length; i++) &#123;</span><br><span class="line">     li &#x3D; document.createElement(&#39;li&#39;);</span><br><span class="line">     li.textContent &#x3D; &#39;text&#39;;</span><br><span class="line">     appendToElement.appendChild(li);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ul &#x3D; document.getElementById(&#39;list&#39;);</span><br><span class="line">ul.style.display &#x3D; &#39;none&#39;; &#x2F;&#x2F; 首先脱离文档流</span><br><span class="line">appendDataToElement(ul, data);</span><br><span class="line">ul.style.display &#x3D; &#39;block&#39;; &#x2F;&#x2F; 操作完以后再可见</span><br></pre></td></tr></table></figure><ul><li>使用文档片段(<code>document fragment</code>)在当前<code>DOM</code>之外构建一个子树，再把它拷贝回文档。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const ul &#x3D; document.getElementById(&#39;list&#39;);</span><br><span class="line">const fragment &#x3D; document.createDocumentFragment()</span><br><span class="line">appendDataToElement(fragment , data);</span><br><span class="line">ul.appendChild(fragment )</span><br></pre></td></tr></table></figure><h4 id="独立图层"><a href="#独立图层" class="headerlink" title="独立图层"></a>独立图层</h4><p>一个图层的回流和重绘只会在该图层当中进行，不会影响其他图层，所以有必要的时候，可以将某些元素放到单独的图层。</p><p>例如对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它<strong>脱离文档流</strong>， 成为一个单独的图层。否则会引起父元素以及后续元素频繁的回流。但是应该尽量少量使用图层，因为图层的合成是特别消耗性能，一个页面当中不能有过多的图层, 在使用了图层之后需要进行前后对比</p><p>会自动建立图层的情况:</p><ul><li>3d或者透视变换、过渡css属性</li><li>使用<video>节点</video></li><li><canvas></canvas></li><li>flash</li><li>多透明度做 css动画</li></ul><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><ul><li>用translate替代top改变: top会触发回流，而前者不会</li><li>用opacity替代visibility： 前者回流重绘都不会触发(前提是它单独在一个图层)，后者两个都会触发</li><li>不要使用table布局，table的可能很小的一个改动会造成回流，很影响性能，应该尽量使用 div。</li><li>动画实现的速度选择:</li><li>对于动画新建图层</li><li>启用GPU硬件加速: 使用transform:translateZ(0) 、transform:translate3d(0,0,0)来开启GPU硬件加速</li></ul><h2 id="CSS-与-JS-是这样阻塞-DOM-解析和渲染的"><a href="#CSS-与-JS-是这样阻塞-DOM-解析和渲染的" class="headerlink" title="CSS 与 JS 是这样阻塞 DOM 解析和渲染的"></a><code>CSS</code> 与 <code>JS</code> 是这样阻塞 <code>DOM</code> 解析和渲染的</h2><p>通过<code>&lt;script&gt;</code>与<code>&lt;link&gt;</code>引入外部资源，当解析到该标签的时候，会进行下载。</p><ol><li><code>CSS</code>脚本的加载不会阻塞 <code>DOM</code> <strong>解析过程</strong>，但是会阻塞<strong>渲染过程</strong>(<code>painting</code>)</li><li><code>JS</code>脚本的加载与执行会阻塞 <code>DOM</code> <strong>解析过程</strong>, 但是不会阻塞后续资源的加载</li><li><code>JS</code>脚本的加载中，如果你确定没必要阻塞 <code>DOM</code> 解析的话，不妨按需要加上 <code>defer</code> 或者 <code>async</code> 属性，此时脚本下载的过程中是不会阻塞 <code>DOM</code> 解析的。</li><li>浏览器遇到 <code>&lt;script&gt;</code>且没有 <code>defer</code> 或 <code>async</code> 属性的标签时，为了<code>&lt;script&gt;</code>标签内部的<code>js</code>提供最新的信息，会触发页面的<strong>回流、重绘</strong>过程。</li><li>如果前面 <code>CSS</code> 资源尚未加载完毕时，浏览器会等待它加载完毕之后再执行脚本。即 <code>css</code> 不阻塞 <code>js</code> 的加载，但阻塞它的执行。</li></ol><p>所以<code>&lt;script&gt;</code>最好放底部(防止阻塞<code>DOM</code>解析)。<code>&lt;link&gt;</code>最好放头部(为渲染过程提供样式)。如果头部同时有<code>&lt;script&gt;</code>与<code>&lt;link&gt;</code>的情况下，最好将<code>&lt;script&gt;</code>放在<code>&lt;link&gt;</code>上面(为了防止<code>CSS</code>脚本加载时间过长，使<code>js</code>等待时间也很长)dd</p><h2 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a><code>defer</code>和<code>async</code></h2><p>直接看图吧，绿色的代表 <code>html</code> 解析，蓝色的代表 <code>javascript</code> 脚本的下载，红色的代表 <code>javaScript</code> 脚本的执行。</p><p>![](/Users/renmianzhi/Library/Application Support/typora-user-images/image-20200622203515053.png)</p><p><strong>一.defer属性</strong></p><p>加了defer属性script标签的页面，运行流程如下：(结合上图)</p><p>1.浏览器开始解析HTML页面</p><p>2.遇到有defer属性的script标签，浏览器继续往下面解析页面，且会并行下载script标签的外部js文件</p><p>3.解析完HTML页面，再执行刚下载的js脚本（在DOMContentLoaded事件触发前执行，即刚刚解析完</p></div></article></div></div></div></div></section></body></html>，且可保证执行顺序就是他们在页面上的先后顺序）<p></p><p>注意事项：</p><p>1.内置js代码的script标签，以及动态生成的script标签，defer属性不生效</p><p>2.有defer属性的script标签脚本文件里不能使用document.write方法</p><p><strong>二.async属性</strong></p><p>流程如下：<br>1.浏览器开始解析页面</p><p>2.遇到有async属性的script标签，会继续往下解析，并且同时另开进程下载脚本</p><p>3.脚本下载完毕，浏览器停止解析，开始执行脚本，执行完毕后继续往下解析</p><p>注意事项：</p><p>1.无法保证脚本的执行顺序，哪个脚本先下载完毕，就先执行哪个</p><p>2.也不能使用document.write方法</p><p>使用场景区分：</p><p>1.脚本之间没有依赖关系的，使用async</p><p>2.脚本之间有依赖关系的，使用defer</p><p>3.若同时使用async和defer，defer不起作用，async生效</p><p>参考：<a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html">阮一峰教程</a></p><div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/posts/e0caf769/" target="_blank">浏览器渲染</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/posts/e0caf769/" target="_blank">浏览器渲染</a><br></span><span>  2.<a class="is-size-6" href="/posts/e0f6e8b1/" target="_blank">居中的实现方法</a><br></span><span>  3.<a class="is-size-6" href="/posts/c382ea1a/" target="_blank">重排（回流）与重绘</a><br></span><span>  4.<a class="is-size-6" href="/posts/df42223e/" target="_blank">Docker-使用</a><br></span><span>  5.<a class="is-size-6" href="/posts/afc5d1b0/" target="_blank">vue语法--特殊attribute</a><br></span><span>  6.<a class="is-size-6" href="/posts/35b861cf/" target="_blank">大纲</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190802135456.png" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190802135550.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/e0f6e8b1/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">居中的实现方法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/e0caf769/"><span class="level-item">浏览器渲染</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-浏览器的渲染过程" href="#浏览器的渲染过程"><span>浏览器的渲染过程</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-生成渲染树-RenderTree" href="#生成渲染树-RenderTree"><span>生成渲染树(RenderTree)</span></a></li><li><a class="is-flex toc-item" id="toc-item-回流-Layout" href="#回流-Layout"><span>回流(Layout)</span></a></li><li><a class="is-flex toc-item" id="toc-item-重绘-Painting" href="#重绘-Painting"><span>重绘(Painting)</span></a></li><li><a class="is-flex toc-item" id="toc-item-何时发生回流重绘" href="#何时发生回流重绘"><span>何时发生回流重绘</span></a></li><li><a class="is-flex toc-item" id="toc-item-基于回流-Layout-、重绘-Painting-的优化方法" href="#基于回流-Layout-、重绘-Painting-的优化方法"><span>基于回流(Layout)、重绘(Painting)的优化方法</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-避免扰乱现代浏览器的优化机制" href="#避免扰乱现代浏览器的优化机制"><span>避免扰乱现代浏览器的优化机制</span></a></li><li><a class="is-flex toc-item" id="toc-item-CSS的修改方式" href="#CSS的修改方式"><span>CSS的修改方式</span></a></li><li><a class="is-flex toc-item" id="toc-item-批量修改DOM" href="#批量修改DOM"><span>批量修改DOM</span></a></li><li><a class="is-flex toc-item" id="toc-item-独立图层" href="#独立图层"><span>独立图层</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-其他优化" href="#其他优化"><span>其他优化</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-CSS-与-JS-是这样阻塞-DOM-解析和渲染的" href="#CSS-与-JS-是这样阻塞-DOM-解析和渲染的"><span>CSS 与 JS 是这样阻塞 DOM 解析和渲染的</span></a></li><li><a class="is-flex toc-item" id="toc-item-defer和async" href="#defer和async"><span>defer和async</span></a></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="https://cdn.jsdelivr.net/gh/remzing/img/images/WechatIMG6.jpeg" alt="Remzing"></figure><p class="title is-size-4 is-block line-height-inherit">Remzing</p><p class="is-size-6 is-block">Coder</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Remzing" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Remzing"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:346351229@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer="defer">function getYiyan(){$.getJSON("https://v1.hitokoto.cn/",function(o){o&&($("#hitokoto").html(""),$("#hitokoto").append("<strong style='color: #3273dc;'>"+o.hitokoto+"</strong><p>来源《"+o.from+"》</p>"))})}$(function(){getYiyan(),$("#hitokoto").click(function(){getYiyan()})})</script></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time datetime="2020-08-06T00:31:53.000Z">2020-08-06</time></p><p class="title is-6"><a class="link-muted" href="/posts/35b861cf/">大纲</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/topic/">topic</a></p></div></article><article class="media"><div class="media-content size-small"><p><time datetime="2020-08-06T00:28:08.000Z">2020-08-06</time></p><p class="title is-6"><a class="link-muted" href="/posts/df42223e/">Docker-使用</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E9%9A%8F%E6%84%9F/">随感</a></p></div></article><article class="media"><div class="media-content size-small"><p><time datetime="2020-08-06T00:25:31.000Z">2020-08-06</time></p><p class="title is-6"><a class="link-muted" href="/posts/e0f6e8b1/">居中的实现方法</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/CSS/">CSS</a></p></div></article><article class="media"><div class="media-content size-small"><p><time datetime="2020-06-18T19:09:22.000Z">2020-06-18</time></p><p class="title is-6"><a class="link-muted" href="/posts/c382ea1a/">重排（回流）与重绘</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Browser/">Browser</a></p></div></article><article class="media"><div class="media-content size-small"><p><time datetime="2020-06-08T19:09:18.000Z">2020-06-08</time></p><p class="title is-6"><a class="link-muted" href="/posts/e0caf769/">浏览器渲染</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Browser/">Browser</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Browser/"><span class="level-start"><span class="level-item">Browser</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/VUE/"><span class="level-start"><span class="level-item">VUE</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/topic/"><span class="level-start"><span class="level-item">topic</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%9A%8F%E6%84%9F/"><span class="level-start"><span class="level-item">随感</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Browser/"><span class="tag">Browser</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/topic/"><span class="tag">topic</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E8%AF%AD%E6%B3%95/"><span class="tag">vue语法</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9A%8F%E6%84%9F/"><span class="tag">随感</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/remzing/img/images/avatar.png" alt="Remzing" height="28"></a><p class="size-small"><span>&copy; 2020 Remzing</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">removeif</a> <br></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Remzing"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={site:{url:"https://remzing.github.io",external_link:{enable:!0,exclude:[]}},article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer="defer"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer="defer"></script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/js/lightgallery.min.js" defer="defer"></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer="defer"></script><script src="/js/toc.js" defer="defer"></script><script src="/js/main.js" defer="defer"></script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer="defer"></script>