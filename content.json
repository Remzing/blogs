{"pages":[{"title":"","text":"个人简介 ​ 必须敢于正视，这才可望敢想，敢说，敢做，敢当。 ​ – 鲁迅 ​ 如果天空是黑暗的，那就摸黑生存；如果发出声音是危险的，那就保持沉默；如果自觉无力发光的，那就蜷伏于墙角。但不要习惯了黑暗就为黑暗辩护；不要为自己的苟且而得意；不要嘲讽那些比自己更勇敢热情的人们。人可以卑微如尘土，不可扭曲如蛆虫。 ​ – 曼德拉 ​ 每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。 ​ – 罗永浩","link":"/about/index.html"}],"posts":[{"title":"CSS&#x2F;实现居中的方法","text":"水平垂直居中这种情形也是有多种实现方式，接下去我们娓娓道来： 方法1：绝对定位与负边距实现（已知高度宽度）这种方式需要知道被垂直居中元素的高和宽，才能计算出margin值，兼容所有浏览器。 12345678910111213141516// css部分 #container { position: relative; } #center { position: absolute; top: 50%; left: 50%; margin: -50px 0 0 -50px; }// html部分(这部分不做变化,下面例子直接共用)&lt;body&gt; &lt;div id='container'&gt; &lt;div id='center' style=&quot;width: 100px;height: 100px;background-color: #666&quot;&gt;center&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 方法2：绝对定位与margin:auto（已知高度宽度）这种方式无需知道被垂直居中元素的高和宽，但不能兼容低版本的IE浏览器。 123456789101112#container { position: relative; height:100px;//必须有个高度 }#center { position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;//注意此处的写法 } 方法3：绝对定位+CSS3(未知元素的高宽)利用Css3的transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中。CSS3的transform固然好用，但在项目的实际运用中必须考虑兼容问题，大量的hack代码可能会导致得不偿失。 123456789#container { position: relative; }#center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } 方法4：flex布局利用flex布局，其中justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而align-items属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。不能兼容低版本的IE浏览器。 123456#container {//直接在父容器设置即可 height: 100vh;//必须有高度 display: flex; justify-content: center; align-items: center; } 方法5：flex/grid与margin:auto(最简单写法)容器元素设为 flex 布局或是grid布局，子元素只要写 margin: auto 即可,不能兼容低版本的IE浏览器。 1234567#container { height: 100vh;//必须有高度 display: grid; }#center { margin: auto; }","link":"/posts/527e2618/"},{"title":"SSR","text":"摘要 1、SSR方案是否只优化了首屏渲染？ ​ 是的 2、SSR在服务端跑客户端代码，要初始化vue框架，要生成虚拟DOM，最后直出HTML，这个过程是否会对服务端的性能造成影响？ 3、客户端代码开发完后，是不是需要在服务端中保留一份完整代码给服务端跑？假如服务端和客户端是分开的两个项目，那岂不是要在服务端安装客户端需要的npm依赖包？ 4、根据每个页面的不同路径，都要做相应的直出？ 5、前后端请求要一致，前端请求有携带session，后端请求要保证一致的情况下，还需要解决session的问题 6、后台直出html后，那JS、css依赖呢，由谁来填入？ 7、后台本质仅仅直出的是HTML字符串，所以前端vue代码初始化的时候，需要接管后台吐出来的html，重新生成虚拟DOM，以及接管后台吐回来的store数据。","link":"/posts/80ae5e79/"},{"title":"重排（回流）与重绘","text":"摘要 浏览器的渲染过程 原理以及优化 浏览器的渲染过程 从上面这个图上，我们可以看到，浏览器渲染过程如下 解析HTML生成DOM树，解析CSS生成CSSOM树 将DOM树和CSSOM树结合生成渲染树renderTree Layout(回流): 根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小） Painting(重绘): 根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上。 生成渲染树(RenderTree) 为了构建渲染树，浏览器主要完成了以下工作 从DOM树的根节点开始遍历每个可见节点。 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。 根据每个可见节点以及其对应的样式，组合生成渲染树。 第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括： 一些不会渲染输出的节点，比如script、meta、link等。 一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。 回流(Layout)前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历,而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值 重绘(Painting)通过回流(Layout)阶段，我们知道了所有的可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。 何时发生回流重绘回流阶段是计算节点的几何信息和位置，那么当页面布局或者几何信息发生改变时，就需要回流。 添加或者删除可见的DOM元素 元素的位置、尺寸发生变化 页面开始渲染的时候(这肯定避免不了) 浏览器的视口尺寸大小发生改变(因为回流是根据浏览器视口的大小来计算元素的位置和尺寸大小) 注意：回流一定会触发重绘，而重绘(非几何信息的样式发生改变)不一定会回流, reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流； 根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。 基于回流(Layout)、重绘(Painting)的优化方法避免扰乱现代浏览器的优化机制在现代浏览器的中，由于每次回流、重绘的时候，都需要额外的计算消耗，因此会通过队列化修改，并批量执行来优化这一过程。浏览器会将修改操作放入队列里面，直到过了一段时间或者达到一个阈值，才清空队列。 但是当你获取布局信息时，会强制刷新队列，例如: 123456789offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightgetComputedStyle()getBoundingClientRect() 上面这些方法，都需要获取最新的布局信息，所以浏览器会强制刷新队列并执行回流、重绘，来获取最新的信息。因此我们在修改样式的时候，应该尽量避免使用上面的属性、方法，如果非要使用，可以先缓存起来然后一起获取。 CSS的修改方式考虑以下代码 1234const el = document.getElementById('el')el.style.padding = 'xxx'el.style.margin = 'xxx'el.style.border = 'xxx' 这里元素的几何信息有三次被修改了，但是现代浏览器会将起缓存起来，但是如果这期间有通过前面列出来的属性、方法访问位置信息的话就会触发三次回流、重绘。所以还是建议通过cssText或者class的方法一次性修改。 1234el.style.cssText += 'border-left: 1px; border-right: 2px; padding:5px;';// 或者el.className += 'xxx'; 批量修改DOM当我们需要对DOM进行一系列修改的时候，可以通过以下几种方式减少回流重绘次数： 隐藏元素，应用修改，重新显示 12345678910111213function appendDataToElement (appendToElement, data) { let li; for ( let i = 0; i &lt; data.length; i++) { li = document.createElement('li'); li.textContent = 'text'; appendToElement.appendChild(li); }}const ul = document.getElementById('list');ul.style.display = 'none'; // 首先脱离文档流appendDataToElement(ul, data);ul.style.display = 'block'; // 操作完以后再可见 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。 1234const ul = document.getElementById('list');const fragment = document.createDocumentFragment()appendDataToElement(fragment , data);ul.appendChild(fragment ) 独立图层一个图层的回流和重绘只会在该图层当中进行，不会影响其他图层，所以有必要的时候，可以将某些元素放到单独的图层。 例如对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流， 成为一个单独的图层。否则会引起父元素以及后续元素频繁的回流。但是应该尽量少量使用图层，因为图层的合成是特别消耗性能，一个页面当中不能有过多的图层, 在使用了图层之后需要进行前后对比 会自动建立图层的情况: 3d或者透视变换、过渡css属性 使用节点 flash 多透明度做 css动画 其他优化 用translate替代top改变: top会触发回流，而前者不会 用opacity替代visibility： 前者回流重绘都不会触发(前提是它单独在一个图层)，后者两个都会触发 不要使用table布局，table的可能很小的一个改动会造成回流，很影响性能，应该尽量使用 div。 动画实现的速度选择: 对于动画新建图层 启用GPU硬件加速: 使用transform:translateZ(0) 、transform:translate3d(0,0,0)来开启GPU硬件加速 CSS 与 JS 是这样阻塞 DOM 解析和渲染的通过&lt;script&gt;与&lt;link&gt;引入外部资源，当解析到该标签的时候，会进行下载。 CSS脚本的加载不会阻塞 DOM 解析过程，但是会阻塞渲染过程(painting) JS脚本的加载与执行会阻塞 DOM 解析过程, 但是不会阻塞后续资源的加载 JS脚本的加载中，如果你确定没必要阻塞 DOM 解析的话，不妨按需要加上 defer 或者 async 属性，此时脚本下载的过程中是不会阻塞 DOM 解析的。 浏览器遇到 &lt;script&gt;且没有 defer 或 async 属性的标签时，为了&lt;script&gt;标签内部的js提供最新的信息，会触发页面的回流、重绘过程。 如果前面 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕之后再执行脚本。即 css 不阻塞 js 的加载，但阻塞它的执行。 所以&lt;script&gt;最好放底部(防止阻塞DOM解析)。&lt;link&gt;最好放头部(为渲染过程提供样式)。如果头部同时有&lt;script&gt;与&lt;link&gt;的情况下，最好将&lt;script&gt;放在&lt;link&gt;上面(为了防止CSS脚本加载时间过长，使js等待时间也很长)dd defer和async直接看图吧，绿色的代表 html 解析，蓝色的代表 javascript 脚本的下载，红色的代表 javaScript 脚本的执行。 ![](/Users/renmianzhi/Library/Application Support/typora-user-images/image-20200622203515053.png) 一.defer属性 加了defer属性script标签的页面，运行流程如下：(结合上图) 1.浏览器开始解析HTML页面 2.遇到有defer属性的script标签，浏览器继续往下面解析页面，且会并行下载script标签的外部js文件 3.解析完HTML页面，再执行刚下载的js脚本（在DOMContentLoaded事件触发前执行，即刚刚解析完，且可保证执行顺序就是他们在页面上的先后顺序） 注意事项： 1.内置js代码的script标签，以及动态生成的script标签，defer属性不生效 2.有defer属性的script标签脚本文件里不能使用document.write方法 二.async属性 流程如下：1.浏览器开始解析页面 2.遇到有async属性的script标签，会继续往下解析，并且同时另开进程下载脚本 3.脚本下载完毕，浏览器停止解析，开始执行脚本，执行完毕后继续往下解析 注意事项： 1.无法保证脚本的执行顺序，哪个脚本先下载完毕，就先执行哪个 2.也不能使用document.write方法 使用场景区分： 1.脚本之间没有依赖关系的，使用async 2.脚本之间有依赖关系的，使用defer 3.若同时使用async和defer，defer不起作用，async生效 参考：阮一峰教程","link":"/posts/c382ea1a/"},{"title":"DevOps&#x2F;Docker&#x2F;Docker 使用","text":"Docker 使用什么是Docker?根据官网描述，我们可以得知，Docker是一个软件/容器平台，使用了虚拟化技术(cgroups，namespaces)来实现操作系统的资源隔离和限制，对于开发人员来说，容器技术为应用的部署提供了沙盒环境，我们可以在独立的容器运行和管理应用程序进程，Docker提供的抽象层使得开发人员之间可以保持开发环境相对的一致，避免了冲突。 下面是在CentOS7下Docker的使用经验记录： 使用下面的shell命令安装Docker 1$ curl -sSL https://get.docker.com/ | sh 安装成功后，使用下面的命令应该能显示Docker的版本信息，说明Docker已经被安装了 12$ docker -vDocker version 19.03.12, build 48a66213fe 之后运行docker images可查看现有镜像 ，如果命令报错： Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 需要重启docker进程，在CentOS7下执行命令： 1systemctl restart docker.service 接着我们使用Docker创建一个nginx的容器: 1$ docker run -d --name=web -p 8080:80 nginx:latest 这条命令表示Docker基于nginx:alpine这个Docker镜像，创建一个名称为web的容器，并把容器内部的80端口与宿主机上的8080端口做映射，使得通过宿主机8080端口的流量转发到容器内部的80端口上。 如果安装的时候提示 Unable to find image 'nginx:latest' locally，这是本地没有这个镜像，它会自动下载，但是没有配置过镜像源的话，默认国外镜像源地址，长时间下载不下来就需要翻墙或者配置镜像源地址， 需要我们为docker设置国内阿里云的镜像加速器或选择其他镜像加速器； 需要修改配置文件 /etc/docker/daemon.json 如下（没有daemon.json文件就创建）： 123{ \"registry-mirrors\": [\"https://alzgoonw.mirror.aliyuncs.com\"] } 之后重启docker, 使用docker info即可查看镜像仓库源地址是否改变 12Registry Mirrors: https://alzgoonw.mirror.aliyuncs.com/ 使用docker ps命令，可以列出正在运行的容器，可以看到，刚才基于nginx镜像创建的容器已经处于运行状态了 现在访问宿主机地址的8080端口，看到nginx的欢迎页面","link":"/posts/f23196db/"},{"title":"vue语法--特殊attribute","text":"摘要主要通过vue官方文档熟悉不常用的语法，查缺补漏 key 面试常考内容，比如问v-for 中为什么要加入key key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素 有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误 最常见的用例是结合 v-for： 123&lt;ul&gt; &lt;li v-for=\"item in items\" :key=\"item.id\"&gt;...&lt;/li&gt;&lt;/ul&gt; 它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用： 完整地触发组件的生命周期钩子 触发过渡 e g : 123&lt;transition&gt; &lt;span :key=\"text\"&gt;{{ text }}&lt;/span&gt;&lt;/transition&gt; 当 text 发生改变时，&lt;span&gt;总是会被替换而不是被修改，因此会触发过渡。 ref ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例： 1234567&lt;!-- `vm.$refs.p` will be the DOM node --&gt;&lt;!-- `vm.$refs.p` 获取到的是DOM节点 --&gt;&lt;p ref=\"p\"&gt;hello&lt;/p&gt;&lt;!-- `vm.$refs.child` will be the child component instance --&gt;&lt;!-- `vm.$refs.child` 返回子组件的实例 --&gt;&lt;child-component ref=\"child\"&gt;&lt;/child-component&gt; 当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。 关于 ref 注册时间的重要说明**：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。 参考：子组件 ref is 用于动态组件且基于 DOM 内模板的限制来工作。 示例： 12345678&lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;&lt;component v-bind:is=\"currentView\"&gt;&lt;/component&gt;&lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;&lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; See also： 动态组件 DOM 模板解析说明 slot，slot-scope， scope 已废弃，推荐 2.6.0 新增的 v-slot。","link":"/posts/afc5d1b0/"},{"title":"interview&#x2F;topic&#x2F;大纲","text":"大纲JS基础基础 原型，原型链，_proto_,constructor,prototype 三者的关系 闭包 call，apply typeof instanceof 对比 深拷贝1234567891011121314// 深拷贝function deepClone (obj){ if(typeof obj != &quot;object&quot;||typeof obj == null){ return obj } let result = {} if(obj instanceof Array){ result = [] } for (key in obj){ result[key] = deepClone(obj[key]) } return result} ES5 ES6+ Promise generator async函数 解构， 字符串模板 Vue 基础语法 高阶用法 React 基础语法 高阶用法 Node webpack基于于node开发 http原理 三次握手四次挥手 webpack tree shank 性能优化 渲染 浏览器","link":"/posts/a04dbccd/"}],"tags":[{"name":"SSR","slug":"SSR","link":"/tags/SSR/"},{"name":"Browser","slug":"Browser","link":"/tags/Browser/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vue语法","slug":"vue语法","link":"/tags/vue%E8%AF%AD%E6%B3%95/"}],"categories":[{"name":"SSR","slug":"SSR","link":"/categories/SSR/"},{"name":"Browser","slug":"Browser","link":"/categories/Browser/"},{"name":"VUE","slug":"VUE","link":"/categories/VUE/"}]}