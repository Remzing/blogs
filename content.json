{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"}],"posts":[{"title":"浏览器渲染","text":"摘要 浏览器渲染原理及流程 DOMContentLoaded与load的区别 各个步骤概览参考：《前端性能监控：window.performance》 页面加载和渲染过程参考：《web页面加载、解析、渲染过程》 渲染引擎简介参考： 《浏览器渲染原理及流程》《DOMContentLoaded与load的区别》《你不知道的 DOMContentLoaded》《浏览器渲染过程》 区分DOMContentLoaded事件和load事件DOMContentLoaded事件： The DOMContentLoaded event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.对应$(document).ready(function() { // …代码… });load事件： The onload property of the GlobalEventHandlers mixin is an EventHandler that processes load events on a Window, XMLHttpRequest, element, etc.对应$(document).load(function() { // …代码… });所以： ​ 如果只是想操作dom元素，那么在ready函数里就可以进行了；DOMContentLoaded事件标志着：html中的css都下载完了，js都下载和执行完了；但是并不保证页面已经被完整渲染。这里引出一个问题：我们为什么一再强调将css放在头部，将js文件放在尾部？常见的回答是：因为浏览器生成Dom树的时候是一行一行读HTML代码的，script标签放在最后面就不会影响前面的页面的渲染。那么问题来了，既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样，因为dom树的生成需要整个文档解析完毕。 ​ First Paint（首次有效绘制）与DOMContentLoaded事件的关系浏览器确实是必须读完全部HTML才能生成完整的Dom树，但是浏览器并不是等到有了一个完整的Dom树才进行渲染。Dom树是深度优先生成的，也可以说是从上往下一个节点一个节点的生成的。一旦有节点生成，浏览器就会尝试着去渲染页面。第一次渲染成功的时间就是First Paint（首次有效绘制）时间。 这里回答上面的问题：“将css放在头部，将js文件放在尾部”是为了尽可能的提前First Paint，减少用户的白屏等待时间。（白屏等待时间=First Paint时间-用户在浏览器中输入网址的时间）“将css放在头部，将js文件放在尾部”并不能提前DOMContentLoaded事件，无论js文件放在哪里，DOMContentLoaded事件都会等所有的js（除了async，见下小节）执行完成之后才会触发。 defer和async区别，以及对DOMContentLoaded事件的影响 同步脚本： 立刻下载、立刻执行，下载和执行的过程都会阻塞对html文档的解析 defer脚本： 立刻下载、等html解析结束之后再执行，下载过程是异步的，执行时html文档已经解析完了，所以不会阻塞对html的解析 async脚本： 立刻下载、立刻执行，下载过程是异步的，执行的过程都会阻塞对html文档的解析 需要注意的是： defer的本意是推迟，也就是说defer脚本仍然属于html的一部分，只有当所有的defer脚本都执行完了之后才会触发DOMContentLoaded事件； async的本意是异步，也就是说async脚本已经不属于html了，所以html解析完成了就会立刻触发DOMContentLoaded事件，不管还有没有async脚本在下载或未执行。 那，既然async脚本是异步的，为什么执行的时候还是会阻塞对html文档的解析呢？答：GUI渲染线程与JS引擎线程是互斥的，因为JS引擎线程在执行过程中可能会发生重绘和回流，所以GUI渲染线程执行时候，JS引擎线程会被挂起，等待GUI渲染线程执行完毕才会执行；JS引擎线程执行时候同理。 所以，如果html中有async脚本的话，那DOMContentLoaded事件触发的时间会受到async脚本执行时机的影响，如果async脚本在html解析完成之前执行就会使DOMContentLoaded事件触发推迟。 4.js引擎简介语法分析预编译阶段执行阶段参考；《js引擎的执行过程》 编译器三大步骤： 1. 解析 （Parsing） 2. 转换 （Transformation） 3. 代码生成 （Code Generation）","link":"/posts/e0caf769/"},{"title":"Node-语法","text":"摘要 了解nodejs特点和应⽤场景, 熟悉node模块系统使⽤ 熟悉基础api使⽤ NodeJS是什么node.js是⼀个异步的事件驱动的JavaScript运⾏时, node.js特性其实是JS的特性： ⾮阻塞I/O 事件驱动 node历史 — 为性能⽽⽣ 并发处理 多进程 - C Apache 多线程 - java 异步IO - js 协程 - lua openresty go deno- go TS","link":"/posts/ad389c01/"},{"title":"SSR","text":"摘要 1、SSR方案是否只优化了首屏渲染？ ​ 是的 2、SSR在服务端跑客户端代码，要初始化vue框架，要生成虚拟DOM，最后直出HTML，这个过程是否会对服务端的性能造成影响？ 3、客户端代码开发完后，是不是需要在服务端中保留一份完整代码给服务端跑？假如服务端和客户端是分开的两个项目，那岂不是要在服务端安装客户端需要的npm依赖包？ 4、根据每个页面的不同路径，都要做相应的直出？ 5、前后端请求要一致，前端请求有携带session，后端请求要保证一致的情况下，还需要解决session的问题 6、后台直出html后，那JS、css依赖呢，由谁来填入？ 7、后台本质仅仅直出的是HTML字符串，所以前端vue代码初始化的时候，需要接管后台吐出来的html，重新生成虚拟DOM，以及接管后台吐回来的store数据。","link":"/posts/80ae5e79/"},{"title":"vue源码解析01","text":"摘要 源码学习步骤： 全盘了解 问题驱动 主线优先 可画流程图 安装调试环境，入口文件切入 Vue 源码下载1git clone https://github.com/vuejs/vue.git 输出文件夹 dist 文件解析有多种模块类型： cjs （commonjs） es （es module） umd 入口文件通过查看package.json里面的script，命令dev 把dev命令 修改为 1\"dev\": \"rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev\" 加入参数 --source-map 方便调试vue源码 从命令中看出 入口文件为scripts/config.js ，且带入环境变量 TARGET:web-full-dev","link":"/posts/ca5f2882/"},{"title":"vue语法--特殊attribute","text":"摘要主要通过vue官方文档熟悉不常用的语法，查缺补漏 key 面试常考内容，比如问v-for 中为什么要加入key key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素 有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误 最常见的用例是结合 v-for： 123&lt;ul&gt; &lt;li v-for=\"item in items\" :key=\"item.id\"&gt;...&lt;/li&gt;&lt;/ul&gt; 它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用： 完整地触发组件的生命周期钩子 触发过渡 e g : 123&lt;transition&gt; &lt;span :key=\"text\"&gt;{{ text }}&lt;/span&gt;&lt;/transition&gt; 当 text 发生改变时，&lt;span&gt;总是会被替换而不是被修改，因此会触发过渡。 ref ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例： 1234567&lt;!-- `vm.$refs.p` will be the DOM node --&gt;&lt;!-- `vm.$refs.p` 获取到的是DOM节点 --&gt;&lt;p ref=\"p\"&gt;hello&lt;/p&gt;&lt;!-- `vm.$refs.child` will be the child component instance --&gt;&lt;!-- `vm.$refs.child` 返回子组件的实例 --&gt;&lt;child-component ref=\"child\"&gt;&lt;/child-component&gt; 当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。 关于 ref 注册时间的重要说明**：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。 参考：子组件 ref is 用于动态组件且基于 DOM 内模板的限制来工作。 示例： 12345678&lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;&lt;component v-bind:is=\"currentView\"&gt;&lt;/component&gt;&lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;&lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; See also： 动态组件 DOM 模板解析说明 slot，slot-scope， scope 已废弃，推荐 2.6.0 新增的 v-slot。","link":"/posts/afc5d1b0/"}],"tags":[{"name":"Browser","slug":"Browser","link":"/tags/Browser/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"SSR","slug":"SSR","link":"/tags/SSR/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vue语法","slug":"vue语法","link":"/tags/vue%E8%AF%AD%E6%B3%95/"}],"categories":[{"name":"Browser","slug":"Browser","link":"/categories/Browser/"},{"name":"Node","slug":"Node","link":"/categories/Node/"},{"name":"SSR","slug":"SSR","link":"/categories/SSR/"},{"name":"VUE","slug":"VUE","link":"/categories/VUE/"}]}