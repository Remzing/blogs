<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Remzing</title>
  
  <subtitle>codeing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://remzing.github.io/"/>
  <updated>2020-06-10T18:47:29.731Z</updated>
  <id>https://remzing.github.io/</id>
  
  <author>
    <name>Remzing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器渲染</title>
    <link href="https://remzing.github.io/posts/e0caf769/"/>
    <id>https://remzing.github.io/posts/e0caf769/</id>
    <published>2020-06-08T19:09:18.000Z</published>
    <updated>2020-06-10T18:47:29.731Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p><ul><li>浏览器渲染原理及流程</li><li>DOMContentLoaded与load的区别<a id="more"></a></li></ul></blockquote><h2 id="各个步骤概览"><a href="#各个步骤概览" class="headerlink" title="各个步骤概览"></a>各个步骤概览</h2><p>参考：<br><a href="https://www.cnblogs.com/libin-1/p/6501951.html">《前端性能监控：window.performance》</a></p><h2 id="页面加载和渲染过程"><a href="#页面加载和渲染过程" class="headerlink" title="页面加载和渲染过程"></a>页面加载和渲染过程</h2><p>参考：<br><a href="https://www.cnblogs.com/CandyManPing/p/6635008.html">《web页面加载、解析、渲染过程》</a></p><h2 id="渲染引擎简介"><a href="#渲染引擎简介" class="headerlink" title="渲染引擎简介"></a>渲染引擎简介</h2><p>参考：</p><p><a href="https://segmentfault.com/a/1190000019072231?utm_medium=referral&utm_source=tuicool">《浏览器渲染原理及流程》</a><br><a href="https://www.cnblogs.com/caizhenbo/p/6679478.html">《DOMContentLoaded与load的区别》</a><br><a href="https://zhuanlan.zhihu.com/p/25876048">《你不知道的 DOMContentLoaded》</a><br><a href="https://heyingye.github.io/2018/03/13/浏览器渲染过程/">《浏览器渲染过程》</a></p><h3 id="区分DOMContentLoaded事件和load事件"><a href="#区分DOMContentLoaded事件和load事件" class="headerlink" title="区分DOMContentLoaded事件和load事件"></a>区分DOMContentLoaded事件和load事件</h3><p>DOMContentLoaded事件：<br>    The DOMContentLoaded event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.<br>对应$(document).ready(function() { // …代码… });<br>load事件：<br>    The onload property of the GlobalEventHandlers mixin is an EventHandler that processes load events on a Window, XMLHttpRequest, <img> element, etc.<br>对应$(document).load(function() { // …代码… });<br>所以：</p><p>​    如果只是想操作dom元素，那么在ready函数里就可以进行了；<br>DOMContentLoaded事件标志着：html中的css都下载完了，js都下载和执行完了；但是并不保证页面已经被完整渲染。<br>这里引出一个问题：<br>我们为什么一再强调将css放在头部，将js文件放在尾部？<br>常见的回答是：因为浏览器生成Dom树的时候是一行一行读HTML代码的，script标签放在最后面就不会影响前面的页面的渲染。<br>那么问题来了，既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样，因为dom树的生成需要整个文档解析完毕。</p><p>​    First Paint（首次有效绘制）与DOMContentLoaded事件的关系<br>浏览器确实是必须读完全部HTML才能生成完整的Dom树，但是浏览器并不是等到有了一个完整的Dom树才进行渲染。Dom树是深度优先生成的，也可以说是从上往下一个节点一个节点的生成的。一旦有节点生成，浏览器就会尝试着去渲染页面。第一次渲染成功的时间就是First Paint（首次有效绘制）时间。</p><p>这里回答上面的问题：<br>“将css放在头部，将js文件放在尾部”是为了尽可能的提前First Paint，减少用户的白屏等待时间。（白屏等待时间=First Paint时间-用户在浏览器中输入网址的时间）<br>“将css放在头部，将js文件放在尾部”并不能提前DOMContentLoaded事件，无论js文件放在哪里，DOMContentLoaded事件都会等所有的js（除了async，见下小节）执行完成之后才会触发。</p><p>defer和async区别，以及对DOMContentLoaded事件的影响</p><ul><li><p>同步脚本：</p><pre><code>立刻下载、立刻执行，下载和执行的过程都会阻塞对html文档的解析</code></pre></li><li><p>defer脚本：</p><pre><code>立刻下载、等html解析结束之后再执行，下载过程是异步的，执行时html文档已经解析完了，所以不会阻塞对html的解析</code></pre></li><li><p>async脚本：</p><pre><code>立刻下载、立刻执行，下载过程是异步的，执行的过程都会阻塞对html文档的解析</code></pre></li></ul><p><strong>需要注意的是：</strong><br>    defer的本意是推迟，也就是说defer脚本仍然属于html的一部分，只有当所有的defer脚本都执行完了之后才会触发DOMContentLoaded事件；<br>    async的本意是异步，也就是说async脚本已经不属于html了，所以html解析完成了就会立刻触发DOMContentLoaded事件，不管还有没有async脚本在下载或未执行。</p><p>那，既然async脚本是异步的，为什么执行的时候还是会阻塞对html文档的解析呢？<br>答：GUI渲染线程与JS引擎线程是互斥的，因为JS引擎线程在执行过程中可能会发生重绘和回流，所以GUI渲染线程执行时候，JS引擎线程会被挂起，等待GUI渲染线程执行完毕才会执行；JS引擎线程执行时候同理。</p><p>所以，如果html中有async脚本的话，那DOMContentLoaded事件触发的时间会受到async脚本执行时机的影响，如果async脚本在html解析完成之前执行就会使DOMContentLoaded事件触发推迟。</p><h2 id="4-js引擎简介"><a href="#4-js引擎简介" class="headerlink" title="4.js引擎简介"></a>4.js引擎简介</h2><p>语法分析<br>预编译阶段<br>执行阶段<br>参考；<br><a href="https://heyingye.github.io/2018/03/19/js引擎的执行过程（一）/">《js引擎的执行过程》</a></p><p>编译器三大步骤：</p><pre><code>1. 解析 （Parsing）2. 转换 （Transformation）3. 代码生成 （Code Generation）</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器渲染原理及流程&lt;/li&gt;
&lt;li&gt;DOMContentLoaded与load的区别
    
    </summary>
    
    
      <category term="Browser" scheme="https://remzing.github.io/categories/Browser/"/>
    
    
      <category term="Browser" scheme="https://remzing.github.io/tags/Browser/"/>
    
  </entry>
  
  <entry>
    <title>vue源码解析01</title>
    <link href="https://remzing.github.io/posts/ca5f2882/"/>
    <id>https://remzing.github.io/posts/ca5f2882/</id>
    <published>2020-06-04T12:40:36.000Z</published>
    <updated>2020-06-10T18:47:29.731Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p><ul><li><p>源码学习步骤：</p><ol><li>全盘了解</li><li>问题驱动</li><li>主线优先</li><li>可画流程图</li></ol></li><li><p>安装调试环境，入口文件切入</p><a id="more"></a></li></ul></blockquote><h2 id="Vue-源码下载"><a href="#Vue-源码下载" class="headerlink" title="Vue 源码下载"></a>Vue 源码下载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vuejs/vue.git</span><br></pre></td></tr></table></figure><h2 id="输出文件夹-dist-文件解析"><a href="#输出文件夹-dist-文件解析" class="headerlink" title="输出文件夹 dist 文件解析"></a>输出文件夹 dist 文件解析</h2><p>有多种模块类型：</p><ul><li>cjs （commonjs）</li><li>es （es module）</li><li>umd</li></ul><h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p>通过查看package.json里面的script，命令dev</p><p>把dev命令 修改为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"dev": "rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev"</span><br></pre></td></tr></table></figure><p>加入参数 <code>--source-map</code> 方便调试vue源码</p><p>从命令中看出 入口文件为<code>scripts/config.js</code> ，且带入环境变量 <code>TARGET:web-full-dev</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;源码学习步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全盘了解&lt;/li&gt;
&lt;li&gt;问题驱动&lt;/li&gt;
&lt;li&gt;主线优先&lt;/li&gt;
&lt;li&gt;可画流程图&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装调试环境，入口文件切入&lt;/p&gt;
    
    </summary>
    
    
      <category term="VUE" scheme="https://remzing.github.io/categories/VUE/"/>
    
    
      <category term="vue" scheme="https://remzing.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>SSR</title>
    <link href="https://remzing.github.io/posts/80ae5e79/"/>
    <id>https://remzing.github.io/posts/80ae5e79/</id>
    <published>2020-05-31T16:53:30.000Z</published>
    <updated>2020-06-10T18:47:29.731Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p><a id="more"></a></blockquote><ul><li><p>1、SSR方案是否只优化了首屏渲染？</p><p>​    是的</p></li><li><p>2、SSR在服务端跑客户端代码，要初始化vue框架，要生成虚拟DOM，最后直出HTML，这个过程是否会对服务端的性能造成影响？</p></li><li><p>3、客户端代码开发完后，是不是需要在服务端中保留一份完整代码给服务端跑？假如服务端和客户端是分开的两个项目，那岂不是要在服务端安装客户端需要的npm依赖包？</p></li><li><p>4、根据每个页面的不同路径，都要做相应的直出？</p></li><li><p>5、前后端请求要一致，前端请求有携带session，后端请求要保证一致的情况下，还需要解决session的问题</p></li><li><p>6、后台直出html后，那JS、css依赖呢，由谁来填入？</p></li><li><p>7、后台本质仅仅直出的是HTML字符串，所以前端vue代码初始化的时候，需要接管后台吐出来的html，重新生成虚拟DOM，以及接管后台吐回来的store数据。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSR" scheme="https://remzing.github.io/categories/SSR/"/>
    
    
      <category term="SSR" scheme="https://remzing.github.io/tags/SSR/"/>
    
  </entry>
  
  <entry>
    <title>Node-语法</title>
    <link href="https://remzing.github.io/posts/ad389c01/"/>
    <id>https://remzing.github.io/posts/ad389c01/</id>
    <published>2020-05-28T13:51:57.000Z</published>
    <updated>2020-06-10T18:47:29.731Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p><ul><li>了解nodejs特点和应⽤场景,</li><li>熟悉node模块系统使⽤</li><li>熟悉基础api使⽤<a id="more"></a></li></ul></blockquote><h2 id="NodeJS是什么"><a href="#NodeJS是什么" class="headerlink" title="NodeJS是什么"></a><strong>NodeJS</strong>是什么</h2><p>node.js是⼀个异步的事件驱动的JavaScript运⾏时, node.js特性其实是JS的特性：</p><ul><li>⾮阻塞I/O</li><li>事件驱动</li></ul><p>node历史 — 为性能⽽⽣ </p><blockquote><p>并发处理    </p></blockquote><ul><li><p>多进程 - C Apache</p></li><li><p>多线程 - java</p></li><li><p>异步IO - js</p></li><li><p>协程 - lua openresty go deno- go TS</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解nodejs特点和应⽤场景,&lt;/li&gt;
&lt;li&gt;熟悉node模块系统使⽤&lt;/li&gt;
&lt;li&gt;熟悉基础api使⽤
    
    </summary>
    
    
      <category term="Node" scheme="https://remzing.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="https://remzing.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>vue语法--特殊attribute</title>
    <link href="https://remzing.github.io/posts/afc5d1b0/"/>
    <id>https://remzing.github.io/posts/afc5d1b0/</id>
    <published>2020-05-27T10:48:49.000Z</published>
    <updated>2020-06-10T18:47:29.731Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>主要通过vue官方文档熟悉不常用的语法，查缺补漏</p><a id="more"></a></blockquote><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><ul><li><p>面试常考内容，比如问v-for 中为什么要加入key</p></li><li><p><code>key</code> 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素</p></li><li><p><code>有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误</code></p><p>最常见的用例是结合 <code>v-for</code>：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"item in items"</span> :key=<span class="string">"item.id"</span>&gt;...&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p><ul><li>完整地触发组件的生命周期钩子</li><li>触发过渡</li></ul><p>e g :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">"text"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 <code>text</code> 发生改变时，<code>&lt;span&gt;</code>总是会被替换而不是被修改，因此会触发过渡。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul><li><code>ref</code> 被用来给<code>元素</code>或<code>子组件</code>注册引用信息。引用信息将会注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向<code>组件实例</code>：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.p` 获取到的是DOM节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">"p"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.child` will be the child component instance --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.child` 返回子组件的实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>当 <code>v-for</code> 用于元素或组件的时候，<code>引用信息将是包含 DOM 节点或组件实例的数组</code>。</p></li><li><p>关于 ref 注册时间的重要说明**：因为 ref 本身是作为渲染结果被创建的，在<code>初始渲染</code>的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#访问子组件实例或子元素"><em>子组件 ref</em></a></p></li></ul><h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><ul><li>用于<a href="https://cn.vuejs.org/v2/guide/components.html#动态组件">动态组件</a>且基于 <a href="https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项">DOM 内模板的限制</a>来工作。</li></ul><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>See also</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/components.html#动态组件">动态组件</a></li><li><a href="https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项">DOM 模板解析说明</a></li></ul><h2 id="slot，slot-scope，-scope"><a href="#slot，slot-scope，-scope" class="headerlink" title="slot，slot-scope， scope"></a>slot，slot-scope， scope</h2><ul><li>已废弃，<strong>推荐 2.6.0 新增的 <a href="https://cn.vuejs.org/v2/api/#v-slot">v-slot</a>。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;主要通过vue官方文档熟悉不常用的语法，查缺补漏&lt;/p&gt;
    
    </summary>
    
    
      <category term="VUE" scheme="https://remzing.github.io/categories/VUE/"/>
    
    
      <category term="vue" scheme="https://remzing.github.io/tags/vue/"/>
    
      <category term="vue语法" scheme="https://remzing.github.io/tags/vue%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
