<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Remzing</title>
  
  <subtitle>codeing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://remzing.github.io/"/>
  <updated>2020-08-04T17:14:05.824Z</updated>
  <id>https://remzing.github.io/</id>
  
  <author>
    <name>Remzing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS/实现居中的方法</title>
    <link href="https://remzing.github.io/posts/527e2618/"/>
    <id>https://remzing.github.io/posts/527e2618/</id>
    <published>2020-08-04T17:14:05.824Z</published>
    <updated>2020-08-04T17:14:05.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>这种情形也是有多种实现方式，接下去我们娓娓道来：</p><h3 id="方法1：绝对定位与负边距实现（已知高度宽度）"><a href="#方法1：绝对定位与负边距实现（已知高度宽度）" class="headerlink" title="方法1：绝对定位与负边距实现（已知高度宽度）"></a>方法1：绝对定位与负边距实现（已知高度宽度）</h3><p><strong>这种方式需要知道被垂直居中元素的高和宽，才能计算出margin值，兼容所有浏览器</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; css部分</span><br><span class="line"> #container &#123;</span><br><span class="line">      position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"> #center &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 50%;</span><br><span class="line">      left: 50%;</span><br><span class="line">      margin: -50px 0 0 -50px;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; html部分(这部分不做变化,下面例子直接共用)</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&#39;container&#39;&gt;</span><br><span class="line">    &lt;div id&#x3D;&#39;center&#39; style&#x3D;&quot;width: 100px;height: 100px;background-color: #666&quot;&gt;center&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h3 id="方法2：绝对定位与margin-auto（已知高度宽度）"><a href="#方法2：绝对定位与margin-auto（已知高度宽度）" class="headerlink" title="方法2：绝对定位与margin:auto（已知高度宽度）"></a>方法2：绝对定位与margin:auto（已知高度宽度）</h3><p><strong>这种方式无需知道被垂直居中元素的高和宽，但不能兼容低版本的IE浏览器。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">     position: relative;</span><br><span class="line">     height:100px;&#x2F;&#x2F;必须有个高度</span><br><span class="line">   &#125;</span><br><span class="line">#center &#123;</span><br><span class="line">     position: absolute;</span><br><span class="line">     top: 0;</span><br><span class="line">     left: 0;</span><br><span class="line">     right: 0;</span><br><span class="line">     bottom: 0;</span><br><span class="line">     margin: auto;&#x2F;&#x2F;注意此处的写法</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="方法3：绝对定位-CSS3-未知元素的高宽"><a href="#方法3：绝对定位-CSS3-未知元素的高宽" class="headerlink" title="方法3：绝对定位+CSS3(未知元素的高宽)"></a>方法3：绝对定位+CSS3(未知元素的高宽)</h3><p><strong>利用Css3的transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中</strong>。<br>CSS3的transform固然好用，但在项目的实际运用中必须考虑兼容问题，大量的hack代码可能会导致得不偿失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">#center &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="方法4：flex布局"><a href="#方法4：flex布局" class="headerlink" title="方法4：flex布局"></a>方法4：flex布局</h3><p><strong>利用flex布局，其中justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而align-items属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。不能兼容低版本的IE浏览器。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;&#x2F;&#x2F;直接在父容器设置即可</span><br><span class="line">   height: 100vh;&#x2F;&#x2F;必须有高度</span><br><span class="line">   display: flex;</span><br><span class="line">   justify-content: center;</span><br><span class="line">   align-items: center;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="方法5：flex-grid与margin-auto-最简单写法"><a href="#方法5：flex-grid与margin-auto-最简单写法" class="headerlink" title="方法5：flex/grid与margin:auto(最简单写法)"></a>方法5：flex/grid与margin:auto(最简单写法)</h3><p><strong>容器元素设为 flex 布局或是grid布局，子元素只要写 margin: auto 即可,不能兼容低版本的IE浏览器。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">    height: 100vh;&#x2F;&#x2F;必须有高度</span><br><span class="line">    display: grid;</span><br><span class="line">  &#125;</span><br><span class="line">#center &#123;</span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;水平垂直居中&quot;&gt;&lt;a href=&quot;#水平垂直居中&quot; class=&quot;headerlink&quot; title=&quot;水平垂直居中&quot;&gt;&lt;/a&gt;水平垂直居中&lt;/h2&gt;&lt;p&gt;这种情形也是有多种实现方式，接下去我们娓娓道来：&lt;/p&gt;
&lt;h3 id=&quot;方法1：绝对定位与负边距实现（已知
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DevOps/Docker/Docker 使用</title>
    <link href="https://remzing.github.io/posts/f23196db/"/>
    <id>https://remzing.github.io/posts/f23196db/</id>
    <published>2020-08-04T17:14:05.824Z</published>
    <updated>2020-08-04T17:14:05.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-使用"><a href="#Docker-使用" class="headerlink" title="Docker 使用"></a>Docker 使用</h2><p>什么是Docker?根据官网描述，我们可以得知，<a href="https://link.zhihu.com/?target=https%3A//www.docker.com/what-docker">Docker</a>是一个软件/容器平台，使用了虚拟化技术(cgroups，namespaces)来实现操作系统的资源隔离和限制，对于开发人员来说，容器技术为应用的部署提供了沙盒环境，我们可以在独立的容器运行和管理应用程序进程，Docker提供的抽象层使得开发人员之间可以保持开发环境相对的一致，避免了冲突。</p><p>下面是在CentOS7下Docker的使用经验记录：</p><p>使用下面的shell命令安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>安装成功后，使用下面的命令应该能显示Docker的版本信息，说明Docker已经被安装了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker -v</span><br><span class="line">Docker version 19.03.12, build 48a66213fe</span><br></pre></td></tr></table></figure><p>之后运行<code>docker images</code>可查看现有镜像 ，如果命令报错：  </p><p><code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code></p><p>需要重启docker进程，在CentOS7下执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><p>接着我们使用Docker创建一个nginx的容器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name=web -p 8080:80 nginx:latest</span><br></pre></td></tr></table></figure><p>这条命令表示Docker基于nginx:alpine这个Docker镜像，创建一个名称为web的容器，并把容器内部的80端口与宿主机上的8080端口做映射，使得通过宿主机8080端口的流量转发到容器内部的80端口上。</p><p>如果安装的时候提示 <code>Unable to find image &#39;nginx:latest&#39; locally</code>，这是本地没有这个镜像，它会自动下载，但是没有配置过镜像源的话，默认国外镜像源地址，长时间下载不下来就需要翻墙或者配置镜像源地址， 需要我们为docker设置国内阿里云的镜像加速器或选择其他镜像加速器；</p><p> 需要修改配置文件  /etc/docker/daemon.json  如下（没有daemon.json文件就创建）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">"registry-mirrors": ["https://alzgoonw.mirror.aliyuncs.com"] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重启docker, 使用<code>docker info</code>即可查看镜像仓库源地址是否改变 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line">  https:&#x2F;&#x2F;alzgoonw.mirror.aliyuncs.com&#x2F;</span><br></pre></td></tr></table></figure><p>使用<code>docker ps</code>命令，可以列出正在运行的容器，可以看到，刚才基于nginx镜像创建的容器已经处于运行状态了</p><p>现在访问宿主机地址的8080端口，看到nginx的欢迎页面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker-使用&quot;&gt;&lt;a href=&quot;#Docker-使用&quot; class=&quot;headerlink&quot; title=&quot;Docker 使用&quot;&gt;&lt;/a&gt;Docker 使用&lt;/h2&gt;&lt;p&gt;什么是Docker?根据官网描述，我们可以得知，&lt;a href=&quot;https://l
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>interview/topic/大纲</title>
    <link href="https://remzing.github.io/posts/a04dbccd/"/>
    <id>https://remzing.github.io/posts/a04dbccd/</id>
    <published>2020-08-04T17:14:05.824Z</published>
    <updated>2020-08-04T17:14:05.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol><li><p>原型，原型链，_<em>proto_</em>,constructor,prototype 三者的关系</p></li><li><p>闭包 </p></li><li><p>call，apply</p></li><li><p>typeof instanceof 对比</p></li></ol>   <figure class="highlight plain"><figcaption><span>深拷贝</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 深拷贝</span><br><span class="line">function deepClone (obj)&#123;</span><br><span class="line">if(typeof obj !&#x3D; &quot;object&quot;||typeof obj &#x3D;&#x3D; null)&#123;</span><br><span class="line">return obj</span><br><span class="line">&#125;</span><br><span class="line">let result &#x3D; &#123;&#125;</span><br><span class="line">if(obj instanceof Array)&#123;</span><br><span class="line">result &#x3D; []</span><br><span class="line">&#125;</span><br><span class="line">for (key in obj)&#123;</span><br><span class="line">result[key] &#x3D; deepClone(obj[key])</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES5-ES6"><a href="#ES5-ES6" class="headerlink" title="ES5 ES6+"></a>ES5 ES6+</h3><ol><li>Promise</li><li>generator</li><li>async函数</li><li>解构，</li><li>字符串模板</li></ol><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ol><li>基础语法</li><li>高阶用法</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ol><li>基础语法</li><li>高阶用法</li></ol><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><ol><li>webpack基于于node开发</li></ol><h2 id="http原理"><a href="#http原理" class="headerlink" title="http原理"></a>http原理</h2><ol><li>三次握手四次挥手</li></ol><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><ol><li>tree shank</li></ol><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li>渲染</li></ol><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h1&gt;&lt;h2 id=&quot;JS基础&quot;&gt;&lt;a href=&quot;#JS基础&quot; class=&quot;headerlink&quot; title=&quot;JS基础&quot;&gt;&lt;/a&gt;JS基础&lt;/h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>重排（回流）与重绘</title>
    <link href="https://remzing.github.io/posts/c382ea1a/"/>
    <id>https://remzing.github.io/posts/c382ea1a/</id>
    <published>2020-06-18T19:09:22.000Z</published>
    <updated>2020-08-04T17:14:05.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p><ul><li>浏览器的渲染过程</li><li>原理以及优化<a id="more"></a></li></ul></blockquote><h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><p><img src="https://cdn.jsdelivr.net/gh/remzing/img/images/bVblB7y" alt=""></p><p>从上面这个图上，我们可以看到，浏览器渲染过程如下</p><ol><li>解析<code>HTML</code>生成<code>DOM</code>树，解析<code>CSS</code>生成<code>CSSOM</code>树</li><li>将<code>DOM</code>树和<code>CSSOM</code>树结合生成渲染树<code>renderTree</code></li><li><code>Layout</code>(回流): 根据生成的渲染树，进行回流(<code>Layout</code>)，得到节点的几何信息（位置，大小）</li><li><code>Painting</code>(重绘): 根据<strong>渲染树</strong>以及<strong>回流</strong>得到的几何信息，得到节点的<strong>绝对像素</strong></li><li><code>Display</code>:将像素发送给<strong>GPU</strong>，展示在页面上。</li></ol><h3 id="生成渲染树-RenderTree"><a href="#生成渲染树-RenderTree" class="headerlink" title="生成渲染树(RenderTree)"></a>生成渲染树(<code>RenderTree</code>)</h3><p><img src="https://cdn.jsdelivr.net/gh/remzing/img/images/bVblCem" alt=""></p><p>为了构建渲染树，浏览器主要完成了以下工作</p><ol><li>从<code>DOM</code>树的根节点开始遍历每个可见节点。</li><li>对于每个可见的节点，找到<code>CSSOM</code>树中对应的规则，并应用它们。</li><li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li></ol><p>第一步中，既然说到了要遍历<strong>可见</strong>的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p><ol><li>一些不会渲染输出的节点，比如<code>script、meta、link</code>等。</li><li>一些通过<code>css</code>进行隐藏的节点。比如<code>display:none</code>。注意，利用<code>visibility</code>和<code>opacity</code>隐藏的节点，还是会显示在渲染树上的。只有<code>display:none</code>的节点才不会显示在渲染树上。</li></ol><h3 id="回流-Layout"><a href="#回流-Layout" class="headerlink" title="回流(Layout)"></a>回流(<code>Layout</code>)</h3><p>前面我们通过构造渲染树，我们将可见<code>DOM</code>节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(<code>viewport</code>)内的确切位置和大小，这个计算的阶段就是回流。<br>为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历,而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值</p><h3 id="重绘-Painting"><a href="#重绘-Painting" class="headerlink" title="重绘(Painting)"></a>重绘(<code>Painting</code>)</h3><p>通过回流(<code>Layout</code>)阶段，我们知道了所有的可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p><h3 id="何时发生回流重绘"><a href="#何时发生回流重绘" class="headerlink" title="何时发生回流重绘"></a>何时发生回流重绘</h3><p>回流阶段是计算节点的几何信息和位置，那么当<strong>页面布局</strong>或者<strong>几何信息</strong>发生改变时，就需要回流。</p><ol><li>添加或者删除可见的<code>DOM</code>元素</li><li>元素的位置、尺寸发生变化</li><li>页面开始渲染的时候(这肯定避免不了)</li><li>浏览器的视口尺寸大小发生改变(因为回流是根据浏览器视口的大小来计算元素的位置和尺寸大小)</li></ol><p><strong>注意：回流一定会触发重绘，而重绘(非几何信息的样式发生改变)不一定会回流, reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流；</strong></p><p>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p><h3 id="基于回流-Layout-、重绘-Painting-的优化方法"><a href="#基于回流-Layout-、重绘-Painting-的优化方法" class="headerlink" title="基于回流(Layout)、重绘(Painting)的优化方法"></a>基于回流(<code>Layout</code>)、重绘(<code>Painting</code>)的优化方法</h3><h4 id="避免扰乱现代浏览器的优化机制"><a href="#避免扰乱现代浏览器的优化机制" class="headerlink" title="避免扰乱现代浏览器的优化机制"></a>避免扰乱现代浏览器的优化机制</h4><p>在现代浏览器的中，由于每次<strong>回流、重绘</strong>的时候，都需要额外的计算消耗，因此会通过<strong>队列化修改</strong>，并批量执行来优化这一过程。浏览器会将修改操作放入队列里面，直到<strong>过了一段时间</strong>或者<strong>达到一个阈值</strong>，才清空队列。</p><p>但是当你获取布局信息时，会强制刷新队列，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">offsetTop、offsetLeft、offsetWidth、offsetHeight</span><br><span class="line"></span><br><span class="line">scrollTop、scrollLeft、scrollWidth、scrollHeight</span><br><span class="line"></span><br><span class="line">clientTop、clientLeft、clientWidth、clientHeight</span><br><span class="line"></span><br><span class="line">getComputedStyle()</span><br><span class="line"></span><br><span class="line">getBoundingClientRect()</span><br></pre></td></tr></table></figure><p>上面这些方法，都需要获取最新的布局信息，所以浏览器会强制刷新队列并执行回流、重绘，来获取最新的信息。<br>因此我们在修改样式的时候，应该尽量避免使用上面的属性、方法，如果非要使用，可以先缓存起来然后一起获取。</p><h4 id="CSS的修改方式"><a href="#CSS的修改方式" class="headerlink" title="CSS的修改方式"></a><code>CSS</code>的修改方式</h4><p>考虑以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const el &#x3D; document.getElementById(&#39;el&#39;)</span><br><span class="line">el.style.padding &#x3D; &#39;xxx&#39;</span><br><span class="line">el.style.margin &#x3D; &#39;xxx&#39;</span><br><span class="line">el.style.border &#x3D; &#39;xxx&#39;</span><br></pre></td></tr></table></figure><p>这里元素的几何信息有三次被修改了，但是现代浏览器会将起缓存起来，但是如果这期间有通过前面列出来的属性、方法访问位置信息的话就会触发三次回流、重绘。所以还是建议通过<code>cssText</code>或者<code>class</code>的方法一次性修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">el.style.cssText +&#x3D; &#39;border-left: 1px; border-right: 2px; padding:</span><br><span class="line">5px;&#39;;</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">el.className +&#x3D; &#39;xxx&#39;;</span><br></pre></td></tr></table></figure><h4 id="批量修改DOM"><a href="#批量修改DOM" class="headerlink" title="批量修改DOM"></a>批量修改<code>DOM</code></h4><p>当我们需要对<code>DOM</code>进行一系列修改的时候，可以通过以下几种方式减少回流重绘次数：</p><ul><li>隐藏元素，应用修改，重新显示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function appendDataToElement (appendToElement, data) &#123; </span><br><span class="line">    let li;</span><br><span class="line">    for ( let i &#x3D; 0; i &lt; data.length; i++) &#123;</span><br><span class="line">     li &#x3D; document.createElement(&#39;li&#39;);</span><br><span class="line">     li.textContent &#x3D; &#39;text&#39;;</span><br><span class="line">     appendToElement.appendChild(li);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ul &#x3D; document.getElementById(&#39;list&#39;);</span><br><span class="line">ul.style.display &#x3D; &#39;none&#39;; &#x2F;&#x2F; 首先脱离文档流</span><br><span class="line">appendDataToElement(ul, data);</span><br><span class="line">ul.style.display &#x3D; &#39;block&#39;; &#x2F;&#x2F; 操作完以后再可见</span><br></pre></td></tr></table></figure><ul><li>使用文档片段(<code>document fragment</code>)在当前<code>DOM</code>之外构建一个子树，再把它拷贝回文档。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const ul &#x3D; document.getElementById(&#39;list&#39;);</span><br><span class="line">const fragment &#x3D; document.createDocumentFragment()</span><br><span class="line">appendDataToElement(fragment , data);</span><br><span class="line">ul.appendChild(fragment )</span><br></pre></td></tr></table></figure><h4 id="独立图层"><a href="#独立图层" class="headerlink" title="独立图层"></a>独立图层</h4><p>一个图层的回流和重绘只会在该图层当中进行，不会影响其他图层，所以有必要的时候，可以将某些元素放到单独的图层。</p><p>例如对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它<strong>脱离文档流</strong>， 成为一个单独的图层。否则会引起父元素以及后续元素频繁的回流。但是应该尽量少量使用图层，因为图层的合成是特别消耗性能，一个页面当中不能有过多的图层, 在使用了图层之后需要进行前后对比</p><p>会自动建立图层的情况:</p><ul><li>3d或者透视变换、过渡css属性</li><li>使用<video>节点</li><li><canvas></li><li>flash</li><li>多透明度做 css动画</li></ul><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><ul><li>用translate替代top改变: top会触发回流，而前者不会</li><li>用opacity替代visibility： 前者回流重绘都不会触发(前提是它单独在一个图层)，后者两个都会触发</li><li>不要使用table布局，table的可能很小的一个改动会造成回流，很影响性能，应该尽量使用 div。</li><li>动画实现的速度选择:</li><li>对于动画新建图层</li><li>启用GPU硬件加速: 使用transform:translateZ(0) 、transform:translate3d(0,0,0)来开启GPU硬件加速</li></ul><h2 id="CSS-与-JS-是这样阻塞-DOM-解析和渲染的"><a href="#CSS-与-JS-是这样阻塞-DOM-解析和渲染的" class="headerlink" title="CSS 与 JS 是这样阻塞 DOM 解析和渲染的"></a><code>CSS</code> 与 <code>JS</code> 是这样阻塞 <code>DOM</code> 解析和渲染的</h2><p>通过<code>&lt;script&gt;</code>与<code>&lt;link&gt;</code>引入外部资源，当解析到该标签的时候，会进行下载。</p><ol><li><code>CSS</code>脚本的加载不会阻塞 <code>DOM</code> <strong>解析过程</strong>，但是会阻塞<strong>渲染过程</strong>(<code>painting</code>)</li><li><code>JS</code>脚本的加载与执行会阻塞 <code>DOM</code> <strong>解析过程</strong>, 但是不会阻塞后续资源的加载</li><li><code>JS</code>脚本的加载中，如果你确定没必要阻塞 <code>DOM</code> 解析的话，不妨按需要加上 <code>defer</code> 或者 <code>async</code> 属性，此时脚本下载的过程中是不会阻塞 <code>DOM</code> 解析的。</li><li>浏览器遇到 <code>&lt;script&gt;</code>且没有 <code>defer</code> 或 <code>async</code> 属性的标签时，为了<code>&lt;script&gt;</code>标签内部的<code>js</code>提供最新的信息，会触发页面的<strong>回流、重绘</strong>过程。</li><li>如果前面 <code>CSS</code> 资源尚未加载完毕时，浏览器会等待它加载完毕之后再执行脚本。即 <code>css</code> 不阻塞 <code>js</code> 的加载，但阻塞它的执行。</li></ol><p>所以<code>&lt;script&gt;</code>最好放底部(防止阻塞<code>DOM</code>解析)。<code>&lt;link&gt;</code>最好放头部(为渲染过程提供样式)。如果头部同时有<code>&lt;script&gt;</code>与<code>&lt;link&gt;</code>的情况下，最好将<code>&lt;script&gt;</code>放在<code>&lt;link&gt;</code>上面(为了防止<code>CSS</code>脚本加载时间过长，使<code>js</code>等待时间也很长)dd</p><h2 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a><code>defer</code>和<code>async</code></h2><p>直接看图吧，绿色的代表 <code>html</code> 解析，蓝色的代表 <code>javascript</code> 脚本的下载，红色的代表 <code>javaScript</code> 脚本的执行。</p><p>![](/Users/renmianzhi/Library/Application Support/typora-user-images/image-20200622203515053.png)</p><p><strong>一.defer属性</strong></p><p>加了defer属性script标签的页面，运行流程如下：(结合上图)</p><p>1.浏览器开始解析HTML页面</p><p>2.遇到有defer属性的script标签，浏览器继续往下面解析页面，且会并行下载script标签的外部js文件</p><p>3.解析完HTML页面，再执行刚下载的js脚本（在DOMContentLoaded事件触发前执行，即刚刚解析完</html>，且可保证执行顺序就是他们在页面上的先后顺序）</p><p>注意事项：</p><p>1.内置js代码的script标签，以及动态生成的script标签，defer属性不生效</p><p>2.有defer属性的script标签脚本文件里不能使用document.write方法</p><p><strong>二.async属性</strong></p><p>流程如下：<br>1.浏览器开始解析页面</p><p>2.遇到有async属性的script标签，会继续往下解析，并且同时另开进程下载脚本</p><p>3.脚本下载完毕，浏览器停止解析，开始执行脚本，执行完毕后继续往下解析</p><p>注意事项：</p><p>1.无法保证脚本的执行顺序，哪个脚本先下载完毕，就先执行哪个</p><p>2.也不能使用document.write方法</p><p>使用场景区分：</p><p>1.脚本之间没有依赖关系的，使用async</p><p>2.脚本之间有依赖关系的，使用defer    </p><p>3.若同时使用async和defer，defer不起作用，async生效</p><p>参考：<a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html">阮一峰教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器的渲染过程&lt;/li&gt;
&lt;li&gt;原理以及优化
    
    </summary>
    
    
      <category term="Browser" scheme="https://remzing.github.io/categories/Browser/"/>
    
    
      <category term="Browser" scheme="https://remzing.github.io/tags/Browser/"/>
    
  </entry>
  
  <entry>
    <title>SSR</title>
    <link href="https://remzing.github.io/posts/80ae5e79/"/>
    <id>https://remzing.github.io/posts/80ae5e79/</id>
    <published>2020-05-31T16:53:30.000Z</published>
    <updated>2020-08-04T17:14:05.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p><a id="more"></a></blockquote><ul><li><p>1、SSR方案是否只优化了首屏渲染？</p><p>​    是的</p></li><li><p>2、SSR在服务端跑客户端代码，要初始化vue框架，要生成虚拟DOM，最后直出HTML，这个过程是否会对服务端的性能造成影响？</p></li><li><p>3、客户端代码开发完后，是不是需要在服务端中保留一份完整代码给服务端跑？假如服务端和客户端是分开的两个项目，那岂不是要在服务端安装客户端需要的npm依赖包？</p></li><li><p>4、根据每个页面的不同路径，都要做相应的直出？</p></li><li><p>5、前后端请求要一致，前端请求有携带session，后端请求要保证一致的情况下，还需要解决session的问题</p></li><li><p>6、后台直出html后，那JS、css依赖呢，由谁来填入？</p></li><li><p>7、后台本质仅仅直出的是HTML字符串，所以前端vue代码初始化的时候，需要接管后台吐出来的html，重新生成虚拟DOM，以及接管后台吐回来的store数据。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSR" scheme="https://remzing.github.io/categories/SSR/"/>
    
    
      <category term="SSR" scheme="https://remzing.github.io/tags/SSR/"/>
    
  </entry>
  
  <entry>
    <title>vue语法--特殊attribute</title>
    <link href="https://remzing.github.io/posts/afc5d1b0/"/>
    <id>https://remzing.github.io/posts/afc5d1b0/</id>
    <published>2020-05-27T10:48:49.000Z</published>
    <updated>2020-08-04T17:14:05.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>主要通过vue官方文档熟悉不常用的语法，查缺补漏</p><a id="more"></a></blockquote><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><ul><li><p>面试常考内容，比如问v-for 中为什么要加入key</p></li><li><p><code>key</code> 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素</p></li><li><p><code>有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误</code></p><p>最常见的用例是结合 <code>v-for</code>：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"item in items"</span> :key=<span class="string">"item.id"</span>&gt;...&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p><ul><li>完整地触发组件的生命周期钩子</li><li>触发过渡</li></ul><p>e g :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">"text"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 <code>text</code> 发生改变时，<code>&lt;span&gt;</code>总是会被替换而不是被修改，因此会触发过渡。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul><li><code>ref</code> 被用来给<code>元素</code>或<code>子组件</code>注册引用信息。引用信息将会注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向<code>组件实例</code>：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.p` 获取到的是DOM节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">"p"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.child` will be the child component instance --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.child` 返回子组件的实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>当 <code>v-for</code> 用于元素或组件的时候，<code>引用信息将是包含 DOM 节点或组件实例的数组</code>。</p></li><li><p>关于 ref 注册时间的重要说明**：因为 ref 本身是作为渲染结果被创建的，在<code>初始渲染</code>的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#访问子组件实例或子元素"><em>子组件 ref</em></a></p></li></ul><h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><ul><li>用于<a href="https://cn.vuejs.org/v2/guide/components.html#动态组件">动态组件</a>且基于 <a href="https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项">DOM 内模板的限制</a>来工作。</li></ul><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>See also</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/components.html#动态组件">动态组件</a></li><li><a href="https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项">DOM 模板解析说明</a></li></ul><h2 id="slot，slot-scope，-scope"><a href="#slot，slot-scope，-scope" class="headerlink" title="slot，slot-scope， scope"></a>slot，slot-scope， scope</h2><ul><li>已废弃，<strong>推荐 2.6.0 新增的 <a href="https://cn.vuejs.org/v2/api/#v-slot">v-slot</a>。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;主要通过vue官方文档熟悉不常用的语法，查缺补漏&lt;/p&gt;
    
    </summary>
    
    
      <category term="VUE" scheme="https://remzing.github.io/categories/VUE/"/>
    
    
      <category term="vue" scheme="https://remzing.github.io/tags/vue/"/>
    
      <category term="vue语法" scheme="https://remzing.github.io/tags/vue%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
