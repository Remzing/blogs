<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Remzing</title>
  
  <subtitle>codeing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://remzing.github.io/"/>
  <updated>2020-08-05T17:29:30.588Z</updated>
  <id>https://remzing.github.io/</id>
  
  <author>
    <name>Remzing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大纲</title>
    <link href="https://remzing.github.io/posts/35b861cf/"/>
    <id>https://remzing.github.io/posts/35b861cf/</id>
    <published>2020-08-06T00:31:53.000Z</published>
    <updated>2020-08-05T17:29:30.588Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p><ul><li>JS基础</li><li>ES5 ES6+</li><li>Vue</li><li>React</li><li>Http</li><li>性能优化<a id="more"></a></li></ul></blockquote><h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol><li><p>原型，原型链，_<em>proto_</em>,constructor,prototype 三者的关系</p></li><li><p>闭包 </p></li><li><p>call，apply</p></li><li><p>typeof instanceof 对比</p></li></ol>   <figure class="highlight plain"><figcaption><span>深拷贝</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 深拷贝</span><br><span class="line">function deepClone (obj)&#123;</span><br><span class="line">if(typeof obj !&#x3D; &quot;object&quot;||typeof obj &#x3D;&#x3D; null)&#123;</span><br><span class="line">return obj</span><br><span class="line">&#125;</span><br><span class="line">let result &#x3D; &#123;&#125;</span><br><span class="line">if(obj instanceof Array)&#123;</span><br><span class="line">result &#x3D; []</span><br><span class="line">&#125;</span><br><span class="line">for (key in obj)&#123;</span><br><span class="line">result[key] &#x3D; deepClone(obj[key])</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES5-ES6"><a href="#ES5-ES6" class="headerlink" title="ES5 ES6+"></a>ES5 ES6+</h3><ol><li>Promise</li><li>generator</li><li>async函数</li><li>解构，</li><li>字符串模板</li></ol><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ol><li>基础语法</li><li>高阶用法</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ol><li>基础语法</li><li>高阶用法</li></ol><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><ol><li>webpack基于于node开发</li></ol><h2 id="http原理"><a href="#http原理" class="headerlink" title="http原理"></a>http原理</h2><ol><li>三次握手四次挥手</li></ol><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><ol><li>tree shank</li></ol><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li>渲染</li></ol><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS基础&lt;/li&gt;
&lt;li&gt;ES5 ES6+&lt;/li&gt;
&lt;li&gt;Vue&lt;/li&gt;
&lt;li&gt;React&lt;/li&gt;
&lt;li&gt;Http&lt;/li&gt;
&lt;li&gt;性能优化
    
    </summary>
    
    
      <category term="topic" scheme="https://remzing.github.io/categories/topic/"/>
    
    
      <category term="topic" scheme="https://remzing.github.io/tags/topic/"/>
    
  </entry>
  
  <entry>
    <title>Docker-使用</title>
    <link href="https://remzing.github.io/posts/df42223e/"/>
    <id>https://remzing.github.io/posts/df42223e/</id>
    <published>2020-08-06T00:28:08.000Z</published>
    <updated>2020-08-05T17:29:30.588Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p><a id="more"></a></blockquote><p>什么是Docker?根据官网描述，我们可以得知，<a href="https://link.zhihu.com/?target=https%3A//www.docker.com/what-docker">Docker</a>是一个软件/容器平台，使用了虚拟化技术(cgroups，namespaces)来实现操作系统的资源隔离和限制，对于开发人员来说，容器技术为应用的部署提供了沙盒环境，我们可以在独立的容器运行和管理应用程序进程，Docker提供的抽象层使得开发人员之间可以保持开发环境相对的一致，避免了冲突。</p><p>下面是在CentOS7下Docker的使用经验记录：</p><p>使用下面的shell命令安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>安装成功后，使用下面的命令应该能显示Docker的版本信息，说明Docker已经被安装了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker -v</span><br><span class="line">Docker version 19.03.12, build 48a66213fe</span><br></pre></td></tr></table></figure><p>之后运行<code>docker images</code>可查看现有镜像 ，如果命令报错：  </p><p><code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code></p><p>需要重启docker进程，在CentOS7下执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><p>接着我们使用Docker创建一个nginx的容器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name=web -p 8080:80 nginx:latest</span><br></pre></td></tr></table></figure><p>这条命令表示Docker基于nginx:alpine这个Docker镜像，创建一个名称为web的容器，并把容器内部的80端口与宿主机上的8080端口做映射，使得通过宿主机8080端口的流量转发到容器内部的80端口上。 </p><p>如果安装的时候提示 <code>Unable to find image &#39;nginx:latest&#39; locally</code>，这是本地没有这个镜像，它会自动下载，但是没有配置过镜像源的话，默认国外镜像源地址，长时间下载不下来就需要翻墙或者配置镜像源地址， 需要我们为docker设置国内阿里云的镜像加速器或选择其他镜像加速器；</p><p> 需要修改配置文件  /etc/docker/daemon.json  如下（没有daemon.json文件就创建）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">"registry-mirrors": ["https://alzgoonw.mirror.aliyuncs.com"] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重启docker, 使用<code>docker info</code>即可查看镜像仓库源地址是否改变 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line">  https:&#x2F;&#x2F;alzgoonw.mirror.aliyuncs.com&#x2F;</span><br></pre></td></tr></table></figure><p>使用<code>docker ps</code>命令，可以列出正在运行的容器，可以看到，刚才基于nginx镜像创建的容器已经处于运行状态了</p><p>现在访问宿主机地址的8080端口，看到nginx的欢迎页面</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
    
    </summary>
    
    
      <category term="随感" scheme="https://remzing.github.io/categories/%E9%9A%8F%E6%84%9F/"/>
    
    
      <category term="随感" scheme="https://remzing.github.io/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>居中的实现方法</title>
    <link href="https://remzing.github.io/posts/e0f6e8b1/"/>
    <id>https://remzing.github.io/posts/e0f6e8b1/</id>
    <published>2020-08-06T00:25:31.000Z</published>
    <updated>2020-08-05T17:29:30.588Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p><a id="more"></a></blockquote><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>这种情形也是有多种实现方式，接下去我们娓娓道来：</p><h3 id="方法1：绝对定位与负边距实现（已知高度宽度）"><a href="#方法1：绝对定位与负边距实现（已知高度宽度）" class="headerlink" title="方法1：绝对定位与负边距实现（已知高度宽度）"></a>方法1：绝对定位与负边距实现（已知高度宽度）</h3><p><strong>这种方式需要知道被垂直居中元素的高和宽，才能计算出margin值，兼容所有浏览器</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; css部分</span><br><span class="line"> #container &#123;</span><br><span class="line">      position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"> #center &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 50%;</span><br><span class="line">      left: 50%;</span><br><span class="line">      margin: -50px 0 0 -50px;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; html部分(这部分不做变化,下面例子直接共用)</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id&#x3D;&#39;container&#39;&gt;</span><br><span class="line">    &lt;div id&#x3D;&#39;center&#39; style&#x3D;&quot;width: 100px;height: 100px;background-color: #666&quot;&gt;center&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure><h3 id="方法2：绝对定位与margin-auto（已知高度宽度）"><a href="#方法2：绝对定位与margin-auto（已知高度宽度）" class="headerlink" title="方法2：绝对定位与margin:auto（已知高度宽度）"></a>方法2：绝对定位与margin:auto（已知高度宽度）</h3><p><strong>这种方式无需知道被垂直居中元素的高和宽，但不能兼容低版本的IE浏览器。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">     position: relative;</span><br><span class="line">     height:100px;&#x2F;&#x2F;必须有个高度</span><br><span class="line">   &#125;</span><br><span class="line">#center &#123;</span><br><span class="line">     position: absolute;</span><br><span class="line">     top: 0;</span><br><span class="line">     left: 0;</span><br><span class="line">     right: 0;</span><br><span class="line">     bottom: 0;</span><br><span class="line">     margin: auto;&#x2F;&#x2F;注意此处的写法</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="方法3：绝对定位-CSS3-未知元素的高宽"><a href="#方法3：绝对定位-CSS3-未知元素的高宽" class="headerlink" title="方法3：绝对定位+CSS3(未知元素的高宽)"></a>方法3：绝对定位+CSS3(未知元素的高宽)</h3><p><strong>利用Css3的transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中</strong>。<br>CSS3的transform固然好用，但在项目的实际运用中必须考虑兼容问题，大量的hack代码可能会导致得不偿失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line">#center &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="方法4：flex布局"><a href="#方法4：flex布局" class="headerlink" title="方法4：flex布局"></a>方法4：flex布局</h3><p><strong>利用flex布局，其中justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而align-items属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。不能兼容低版本的IE浏览器。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;&#x2F;&#x2F;直接在父容器设置即可</span><br><span class="line">   height: 100vh;&#x2F;&#x2F;必须有高度</span><br><span class="line">   display: flex;</span><br><span class="line">   justify-content: center;</span><br><span class="line">   align-items: center;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="方法5：flex-grid与margin-auto-最简单写法"><a href="#方法5：flex-grid与margin-auto-最简单写法" class="headerlink" title="方法5：flex/grid与margin:auto(最简单写法)"></a>方法5：flex/grid与margin:auto(最简单写法)</h3><p><strong>容器元素设为 flex 布局或是grid布局，子元素只要写 margin: auto 即可,不能兼容低版本的IE浏览器。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">    height: 100vh;&#x2F;&#x2F;必须有高度</span><br><span class="line">    display: grid;</span><br><span class="line">  &#125;</span><br><span class="line">#center &#123;</span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://remzing.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://remzing.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>重排（回流）与重绘</title>
    <link href="https://remzing.github.io/posts/c382ea1a/"/>
    <id>https://remzing.github.io/posts/c382ea1a/</id>
    <published>2020-06-18T19:09:22.000Z</published>
    <updated>2020-08-05T17:29:30.588Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p><ul><li>浏览器的渲染过程</li><li>原理以及优化<a id="more"></a></li></ul></blockquote><h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><p><img src="https://cdn.jsdelivr.net/gh/remzing/img/images/bVblB7y" alt=""></p><p>从上面这个图上，我们可以看到，浏览器渲染过程如下</p><ol><li>解析<code>HTML</code>生成<code>DOM</code>树，解析<code>CSS</code>生成<code>CSSOM</code>树</li><li>将<code>DOM</code>树和<code>CSSOM</code>树结合生成渲染树<code>renderTree</code></li><li><code>Layout</code>(回流): 根据生成的渲染树，进行回流(<code>Layout</code>)，得到节点的几何信息（位置，大小）</li><li><code>Painting</code>(重绘): 根据<strong>渲染树</strong>以及<strong>回流</strong>得到的几何信息，得到节点的<strong>绝对像素</strong></li><li><code>Display</code>:将像素发送给<strong>GPU</strong>，展示在页面上。</li></ol><h3 id="生成渲染树-RenderTree"><a href="#生成渲染树-RenderTree" class="headerlink" title="生成渲染树(RenderTree)"></a>生成渲染树(<code>RenderTree</code>)</h3><p><img src="https://cdn.jsdelivr.net/gh/remzing/img/images/bVblCem" alt=""></p><p>为了构建渲染树，浏览器主要完成了以下工作</p><ol><li>从<code>DOM</code>树的根节点开始遍历每个可见节点。</li><li>对于每个可见的节点，找到<code>CSSOM</code>树中对应的规则，并应用它们。</li><li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li></ol><p>第一步中，既然说到了要遍历<strong>可见</strong>的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p><ol><li>一些不会渲染输出的节点，比如<code>script、meta、link</code>等。</li><li>一些通过<code>css</code>进行隐藏的节点。比如<code>display:none</code>。注意，利用<code>visibility</code>和<code>opacity</code>隐藏的节点，还是会显示在渲染树上的。只有<code>display:none</code>的节点才不会显示在渲染树上。</li></ol><h3 id="回流-Layout"><a href="#回流-Layout" class="headerlink" title="回流(Layout)"></a>回流(<code>Layout</code>)</h3><p>前面我们通过构造渲染树，我们将可见<code>DOM</code>节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(<code>viewport</code>)内的确切位置和大小，这个计算的阶段就是回流。<br>为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历,而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值</p><h3 id="重绘-Painting"><a href="#重绘-Painting" class="headerlink" title="重绘(Painting)"></a>重绘(<code>Painting</code>)</h3><p>通过回流(<code>Layout</code>)阶段，我们知道了所有的可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p><h3 id="何时发生回流重绘"><a href="#何时发生回流重绘" class="headerlink" title="何时发生回流重绘"></a>何时发生回流重绘</h3><p>回流阶段是计算节点的几何信息和位置，那么当<strong>页面布局</strong>或者<strong>几何信息</strong>发生改变时，就需要回流。</p><ol><li>添加或者删除可见的<code>DOM</code>元素</li><li>元素的位置、尺寸发生变化</li><li>页面开始渲染的时候(这肯定避免不了)</li><li>浏览器的视口尺寸大小发生改变(因为回流是根据浏览器视口的大小来计算元素的位置和尺寸大小)</li></ol><p><strong>注意：回流一定会触发重绘，而重绘(非几何信息的样式发生改变)不一定会回流, reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流；</strong></p><p>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p><h3 id="基于回流-Layout-、重绘-Painting-的优化方法"><a href="#基于回流-Layout-、重绘-Painting-的优化方法" class="headerlink" title="基于回流(Layout)、重绘(Painting)的优化方法"></a>基于回流(<code>Layout</code>)、重绘(<code>Painting</code>)的优化方法</h3><h4 id="避免扰乱现代浏览器的优化机制"><a href="#避免扰乱现代浏览器的优化机制" class="headerlink" title="避免扰乱现代浏览器的优化机制"></a>避免扰乱现代浏览器的优化机制</h4><p>在现代浏览器的中，由于每次<strong>回流、重绘</strong>的时候，都需要额外的计算消耗，因此会通过<strong>队列化修改</strong>，并批量执行来优化这一过程。浏览器会将修改操作放入队列里面，直到<strong>过了一段时间</strong>或者<strong>达到一个阈值</strong>，才清空队列。</p><p>但是当你获取布局信息时，会强制刷新队列，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">offsetTop、offsetLeft、offsetWidth、offsetHeight</span><br><span class="line"></span><br><span class="line">scrollTop、scrollLeft、scrollWidth、scrollHeight</span><br><span class="line"></span><br><span class="line">clientTop、clientLeft、clientWidth、clientHeight</span><br><span class="line"></span><br><span class="line">getComputedStyle()</span><br><span class="line"></span><br><span class="line">getBoundingClientRect()</span><br></pre></td></tr></table></figure><p>上面这些方法，都需要获取最新的布局信息，所以浏览器会强制刷新队列并执行回流、重绘，来获取最新的信息。<br>因此我们在修改样式的时候，应该尽量避免使用上面的属性、方法，如果非要使用，可以先缓存起来然后一起获取。</p><h4 id="CSS的修改方式"><a href="#CSS的修改方式" class="headerlink" title="CSS的修改方式"></a><code>CSS</code>的修改方式</h4><p>考虑以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const el &#x3D; document.getElementById(&#39;el&#39;)</span><br><span class="line">el.style.padding &#x3D; &#39;xxx&#39;</span><br><span class="line">el.style.margin &#x3D; &#39;xxx&#39;</span><br><span class="line">el.style.border &#x3D; &#39;xxx&#39;</span><br></pre></td></tr></table></figure><p>这里元素的几何信息有三次被修改了，但是现代浏览器会将起缓存起来，但是如果这期间有通过前面列出来的属性、方法访问位置信息的话就会触发三次回流、重绘。所以还是建议通过<code>cssText</code>或者<code>class</code>的方法一次性修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">el.style.cssText +&#x3D; &#39;border-left: 1px; border-right: 2px; padding:</span><br><span class="line">5px;&#39;;</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">el.className +&#x3D; &#39;xxx&#39;;</span><br></pre></td></tr></table></figure><h4 id="批量修改DOM"><a href="#批量修改DOM" class="headerlink" title="批量修改DOM"></a>批量修改<code>DOM</code></h4><p>当我们需要对<code>DOM</code>进行一系列修改的时候，可以通过以下几种方式减少回流重绘次数：</p><ul><li>隐藏元素，应用修改，重新显示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function appendDataToElement (appendToElement, data) &#123; </span><br><span class="line">    let li;</span><br><span class="line">    for ( let i &#x3D; 0; i &lt; data.length; i++) &#123;</span><br><span class="line">     li &#x3D; document.createElement(&#39;li&#39;);</span><br><span class="line">     li.textContent &#x3D; &#39;text&#39;;</span><br><span class="line">     appendToElement.appendChild(li);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ul &#x3D; document.getElementById(&#39;list&#39;);</span><br><span class="line">ul.style.display &#x3D; &#39;none&#39;; &#x2F;&#x2F; 首先脱离文档流</span><br><span class="line">appendDataToElement(ul, data);</span><br><span class="line">ul.style.display &#x3D; &#39;block&#39;; &#x2F;&#x2F; 操作完以后再可见</span><br></pre></td></tr></table></figure><ul><li>使用文档片段(<code>document fragment</code>)在当前<code>DOM</code>之外构建一个子树，再把它拷贝回文档。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const ul &#x3D; document.getElementById(&#39;list&#39;);</span><br><span class="line">const fragment &#x3D; document.createDocumentFragment()</span><br><span class="line">appendDataToElement(fragment , data);</span><br><span class="line">ul.appendChild(fragment )</span><br></pre></td></tr></table></figure><h4 id="独立图层"><a href="#独立图层" class="headerlink" title="独立图层"></a>独立图层</h4><p>一个图层的回流和重绘只会在该图层当中进行，不会影响其他图层，所以有必要的时候，可以将某些元素放到单独的图层。</p><p>例如对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它<strong>脱离文档流</strong>， 成为一个单独的图层。否则会引起父元素以及后续元素频繁的回流。但是应该尽量少量使用图层，因为图层的合成是特别消耗性能，一个页面当中不能有过多的图层, 在使用了图层之后需要进行前后对比</p><p>会自动建立图层的情况:</p><ul><li>3d或者透视变换、过渡css属性</li><li>使用<video>节点</li><li><canvas></li><li>flash</li><li>多透明度做 css动画</li></ul><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><ul><li>用translate替代top改变: top会触发回流，而前者不会</li><li>用opacity替代visibility： 前者回流重绘都不会触发(前提是它单独在一个图层)，后者两个都会触发</li><li>不要使用table布局，table的可能很小的一个改动会造成回流，很影响性能，应该尽量使用 div。</li><li>动画实现的速度选择:</li><li>对于动画新建图层</li><li>启用GPU硬件加速: 使用transform:translateZ(0) 、transform:translate3d(0,0,0)来开启GPU硬件加速</li></ul><h2 id="CSS-与-JS-是这样阻塞-DOM-解析和渲染的"><a href="#CSS-与-JS-是这样阻塞-DOM-解析和渲染的" class="headerlink" title="CSS 与 JS 是这样阻塞 DOM 解析和渲染的"></a><code>CSS</code> 与 <code>JS</code> 是这样阻塞 <code>DOM</code> 解析和渲染的</h2><p>通过<code>&lt;script&gt;</code>与<code>&lt;link&gt;</code>引入外部资源，当解析到该标签的时候，会进行下载。</p><ol><li><code>CSS</code>脚本的加载不会阻塞 <code>DOM</code> <strong>解析过程</strong>，但是会阻塞<strong>渲染过程</strong>(<code>painting</code>)</li><li><code>JS</code>脚本的加载与执行会阻塞 <code>DOM</code> <strong>解析过程</strong>, 但是不会阻塞后续资源的加载</li><li><code>JS</code>脚本的加载中，如果你确定没必要阻塞 <code>DOM</code> 解析的话，不妨按需要加上 <code>defer</code> 或者 <code>async</code> 属性，此时脚本下载的过程中是不会阻塞 <code>DOM</code> 解析的。</li><li>浏览器遇到 <code>&lt;script&gt;</code>且没有 <code>defer</code> 或 <code>async</code> 属性的标签时，为了<code>&lt;script&gt;</code>标签内部的<code>js</code>提供最新的信息，会触发页面的<strong>回流、重绘</strong>过程。</li><li>如果前面 <code>CSS</code> 资源尚未加载完毕时，浏览器会等待它加载完毕之后再执行脚本。即 <code>css</code> 不阻塞 <code>js</code> 的加载，但阻塞它的执行。</li></ol><p>所以<code>&lt;script&gt;</code>最好放底部(防止阻塞<code>DOM</code>解析)。<code>&lt;link&gt;</code>最好放头部(为渲染过程提供样式)。如果头部同时有<code>&lt;script&gt;</code>与<code>&lt;link&gt;</code>的情况下，最好将<code>&lt;script&gt;</code>放在<code>&lt;link&gt;</code>上面(为了防止<code>CSS</code>脚本加载时间过长，使<code>js</code>等待时间也很长)dd</p><h2 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a><code>defer</code>和<code>async</code></h2><p>直接看图吧，绿色的代表 <code>html</code> 解析，蓝色的代表 <code>javascript</code> 脚本的下载，红色的代表 <code>javaScript</code> 脚本的执行。</p><p>![](/Users/renmianzhi/Library/Application Support/typora-user-images/image-20200622203515053.png)</p><p><strong>一.defer属性</strong></p><p>加了defer属性script标签的页面，运行流程如下：(结合上图)</p><p>1.浏览器开始解析HTML页面</p><p>2.遇到有defer属性的script标签，浏览器继续往下面解析页面，且会并行下载script标签的外部js文件</p><p>3.解析完HTML页面，再执行刚下载的js脚本（在DOMContentLoaded事件触发前执行，即刚刚解析完</html>，且可保证执行顺序就是他们在页面上的先后顺序）</p><p>注意事项：</p><p>1.内置js代码的script标签，以及动态生成的script标签，defer属性不生效</p><p>2.有defer属性的script标签脚本文件里不能使用document.write方法</p><p><strong>二.async属性</strong></p><p>流程如下：<br>1.浏览器开始解析页面</p><p>2.遇到有async属性的script标签，会继续往下解析，并且同时另开进程下载脚本</p><p>3.脚本下载完毕，浏览器停止解析，开始执行脚本，执行完毕后继续往下解析</p><p>注意事项：</p><p>1.无法保证脚本的执行顺序，哪个脚本先下载完毕，就先执行哪个</p><p>2.也不能使用document.write方法</p><p>使用场景区分：</p><p>1.脚本之间没有依赖关系的，使用async</p><p>2.脚本之间有依赖关系的，使用defer    </p><p>3.若同时使用async和defer，defer不起作用，async生效</p><p>参考：<a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html">阮一峰教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器的渲染过程&lt;/li&gt;
&lt;li&gt;原理以及优化
    
    </summary>
    
    
      <category term="Browser" scheme="https://remzing.github.io/categories/Browser/"/>
    
    
      <category term="Browser" scheme="https://remzing.github.io/tags/Browser/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染</title>
    <link href="https://remzing.github.io/posts/e0caf769/"/>
    <id>https://remzing.github.io/posts/e0caf769/</id>
    <published>2020-06-08T19:09:18.000Z</published>
    <updated>2020-08-05T17:29:30.588Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p><ul><li>浏览器渲染原理及流程</li><li>DOMContentLoaded与load的区别<a id="more"></a></li></ul></blockquote><h2 id="各个步骤概览"><a href="#各个步骤概览" class="headerlink" title="各个步骤概览"></a>各个步骤概览</h2><p>参考：<br><a href="https://www.cnblogs.com/libin-1/p/6501951.html">《前端性能监控：window.performance》</a></p><h2 id="页面加载和渲染过程"><a href="#页面加载和渲染过程" class="headerlink" title="页面加载和渲染过程"></a>页面加载和渲染过程</h2><p>参考：<br><a href="https://www.cnblogs.com/CandyManPing/p/6635008.html">《web页面加载、解析、渲染过程》</a></p><h2 id="渲染引擎简介"><a href="#渲染引擎简介" class="headerlink" title="渲染引擎简介"></a>渲染引擎简介</h2><p>参考：</p><p><a href="https://segmentfault.com/a/1190000019072231?utm_medium=referral&utm_source=tuicool">《浏览器渲染原理及流程》</a><br><a href="https://www.cnblogs.com/caizhenbo/p/6679478.html">《DOMContentLoaded与load的区别》</a><br><a href="https://zhuanlan.zhihu.com/p/25876048">《你不知道的 DOMContentLoaded》</a><br><a href="https://heyingye.github.io/2018/03/13/浏览器渲染过程/">《浏览器渲染过程》</a></p><h3 id="区分DOMContentLoaded事件和load事件"><a href="#区分DOMContentLoaded事件和load事件" class="headerlink" title="区分DOMContentLoaded事件和load事件"></a>区分DOMContentLoaded事件和load事件</h3><p>DOMContentLoaded事件：<br>    The DOMContentLoaded event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.<br>对应$(document).ready(function() { // …代码… });<br>load事件：<br>    The onload property of the GlobalEventHandlers mixin is an EventHandler that processes load events on a Window, XMLHttpRequest, <img> element, etc.<br>对应$(document).load(function() { // …代码… });<br>所以：</p><p>​    如果只是想操作dom元素，那么在ready函数里就可以进行了；<br>DOMContentLoaded事件标志着：html中的css都下载完了，js都下载和执行完了；但是并不保证页面已经被完整渲染。<br>这里引出一个问题：<br>我们为什么一再强调将css放在头部，将js文件放在尾部？<br>常见的回答是：因为浏览器生成Dom树的时候是一行一行读HTML代码的，script标签放在最后面就不会影响前面的页面的渲染。<br>那么问题来了，既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样，因为dom树的生成需要整个文档解析完毕。</p><p>​    First Paint（首次有效绘制）与DOMContentLoaded事件的关系<br>浏览器确实是必须读完全部HTML才能生成完整的Dom树，但是浏览器并不是等到有了一个完整的Dom树才进行渲染。Dom树是深度优先生成的，也可以说是从上往下一个节点一个节点的生成的。一旦有节点生成，浏览器就会尝试着去渲染页面。第一次渲染成功的时间就是First Paint（首次有效绘制）时间。</p><p>这里回答上面的问题：<br>“将css放在头部，将js文件放在尾部”是为了尽可能的提前First Paint，减少用户的白屏等待时间。（白屏等待时间=First Paint时间-用户在浏览器中输入网址的时间）<br>“将css放在头部，将js文件放在尾部”并不能提前DOMContentLoaded事件，无论js文件放在哪里，DOMContentLoaded事件都会等所有的js（除了async，见下小节）执行完成之后才会触发。</p><p>defer和async区别，以及对DOMContentLoaded事件的影响</p><ul><li><p>同步脚本：</p><pre><code>立刻下载、立刻执行，下载和执行的过程都会阻塞对html文档的解析</code></pre></li><li><p>defer脚本：</p><pre><code>立刻下载、等html解析结束之后再执行，下载过程是异步的，执行时html文档已经解析完了，所以不会阻塞对html的解析</code></pre></li><li><p>async脚本：</p><pre><code>立刻下载、立刻执行，下载过程是异步的，执行的过程都会阻塞对html文档的解析</code></pre></li></ul><p><strong>需要注意的是：</strong><br>    defer的本意是推迟，也就是说defer脚本仍然属于html的一部分，只有当所有的defer脚本都执行完了之后才会触发DOMContentLoaded事件；<br>    async的本意是异步，也就是说async脚本已经不属于html了，所以html解析完成了就会立刻触发DOMContentLoaded事件，不管还有没有async脚本在下载或未执行。</p><p>那，既然async脚本是异步的，为什么执行的时候还是会阻塞对html文档的解析呢？<br>答：GUI渲染线程与JS引擎线程是互斥的，因为JS引擎线程在执行过程中可能会发生重绘和回流，所以GUI渲染线程执行时候，JS引擎线程会被挂起，等待GUI渲染线程执行完毕才会执行；JS引擎线程执行时候同理。</p><p>所以，如果html中有async脚本的话，那DOMContentLoaded事件触发的时间会受到async脚本执行时机的影响，如果async脚本在html解析完成之前执行就会使DOMContentLoaded事件触发推迟。</p><h2 id="4-js引擎简介"><a href="#4-js引擎简介" class="headerlink" title="4.js引擎简介"></a>4.js引擎简介</h2><p>语法分析<br>预编译阶段<br>执行阶段<br>参考；<br><a href="https://heyingye.github.io/2018/03/19/js引擎的执行过程（一）/">《js引擎的执行过程》</a></p><p>编译器三大步骤：</p><pre><code>1. 解析 （Parsing）2. 转换 （Transformation）3. 代码生成 （Code Generation）</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器渲染原理及流程&lt;/li&gt;
&lt;li&gt;DOMContentLoaded与load的区别
    
    </summary>
    
    
      <category term="Browser" scheme="https://remzing.github.io/categories/Browser/"/>
    
    
      <category term="Browser" scheme="https://remzing.github.io/tags/Browser/"/>
    
  </entry>
  
  <entry>
    <title>vue语法--特殊attribute</title>
    <link href="https://remzing.github.io/posts/afc5d1b0/"/>
    <id>https://remzing.github.io/posts/afc5d1b0/</id>
    <published>2020-05-27T10:48:49.000Z</published>
    <updated>2020-08-05T17:29:30.588Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>主要通过vue官方文档熟悉不常用的语法，查缺补漏</p><a id="more"></a></blockquote><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><ul><li><p>面试常考内容，比如问v-for 中为什么要加入key</p></li><li><p><code>key</code> 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素</p></li><li><p><code>有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误</code></p><p>最常见的用例是结合 <code>v-for</code>：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"item in items"</span> :key=<span class="string">"item.id"</span>&gt;...&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p><ul><li>完整地触发组件的生命周期钩子</li><li>触发过渡</li></ul><p>e g :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">"text"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 <code>text</code> 发生改变时，<code>&lt;span&gt;</code>总是会被替换而不是被修改，因此会触发过渡。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul><li><code>ref</code> 被用来给<code>元素</code>或<code>子组件</code>注册引用信息。引用信息将会注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向<code>组件实例</code>：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.p` 获取到的是DOM节点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">"p"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.child` will be the child component instance --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `vm.$refs.child` 返回子组件的实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>当 <code>v-for</code> 用于元素或组件的时候，<code>引用信息将是包含 DOM 节点或组件实例的数组</code>。</p></li><li><p>关于 ref 注册时间的重要说明**：因为 ref 本身是作为渲染结果被创建的，在<code>初始渲染</code>的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p></li><li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/components-edge-cases.html#访问子组件实例或子元素"><em>子组件 ref</em></a></p></li></ul><h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><ul><li>用于<a href="https://cn.vuejs.org/v2/guide/components.html#动态组件">动态组件</a>且基于 <a href="https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项">DOM 内模板的限制</a>来工作。</li></ul><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>See also</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/components.html#动态组件">动态组件</a></li><li><a href="https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项">DOM 模板解析说明</a></li></ul><h2 id="slot，slot-scope，-scope"><a href="#slot，slot-scope，-scope" class="headerlink" title="slot，slot-scope， scope"></a>slot，slot-scope， scope</h2><ul><li>已废弃，<strong>推荐 2.6.0 新增的 <a href="https://cn.vuejs.org/v2/api/#v-slot">v-slot</a>。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要&lt;br&gt;主要通过vue官方文档熟悉不常用的语法，查缺补漏&lt;/p&gt;
    
    </summary>
    
    
      <category term="VUE" scheme="https://remzing.github.io/categories/VUE/"/>
    
    
      <category term="vue" scheme="https://remzing.github.io/tags/vue/"/>
    
      <category term="vue语法" scheme="https://remzing.github.io/tags/vue%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
